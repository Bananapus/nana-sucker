{
	"solcVersion": "0.8.23",
	"solcLongVersion": "0.8.23",
	"id": "c64234cf4c9da5e7c54eb90852eb1f57",
	"input": {
		"language": "Solidity",
		"settings": {
			"viaIR": false,
			"optimizer": {
				"runs": 200,
				"enabled": true
			},
			"metadata": {
				"useLiteralContent": false,
				"bytecodeHash": "ipfs",
				"appendCBOR": true
			},
			"outputSelection": {
				"*": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				}
			},
			"evmVersion": "paris",
			"libraries": {},
			"remappings": [
				"@sphinx-labs/contracts/=node_modules/@sphinx-labs/contracts/contracts/foundry/",
				"@arbitrum/=node_modules/@arbitrum/",
				"@bananapus/=node_modules/@bananapus/",
				"@chainlink/=node_modules/@chainlink/",
				"@eth-optimism/=node_modules/@eth-optimism/",
				"@offchainlabs/=node_modules/@offchainlabs/",
				"@openzeppelin/=node_modules/@openzeppelin/",
				"@prb/=node_modules/@prb/",
				"@scroll-tech/=node_modules/@scroll-tech/",
				"@uniswap/=node_modules/@uniswap/",
				"ds-test/=lib/forge-std/lib/ds-test/src/",
				"forge-std/=lib/forge-std/src/",
				"hardhat/=node_modules/hardhat/",
				"solmate/=node_modules/solmate/",
				"sphinx/=lib/sphinx/packages/contracts/contracts/forge-std/src/"
			]
		},
		"sources": {
			"node_modules/@bananapus/core/src/abstract/JBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {IJBPermissioned} from \"./../interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"./../interfaces/IJBPermissions.sol\";\n\n/// @notice Modifiers to allow access to transactions based on which permissions the message's sender has.\nabstract contract JBPermissioned is Context, IJBPermissioned {\n    //*********************************************************************//\n    // --------------------------- custom errors -------------------------- //\n    //*********************************************************************//\n    error UNAUTHORIZED();\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice A contract storing permissions.\n    IJBPermissions public immutable override PERMISSIONS;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    constructor(IJBPermissions permissions) {\n        PERMISSIONS = permissions;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Require the message sender to be the account or have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    function _requirePermissionFrom(address account, uint256 projectId, uint256 permissionId) internal view {\n        address sender = _msgSender();\n        if (\n            sender != account\n                && !PERMISSIONS.hasPermission({\n                    operator: sender,\n                    account: account,\n                    projectId: projectId,\n                    permissionId: permissionId,\n                    includeRoot: true,\n                    includeWildcardProjectId: true\n                })\n        ) revert UNAUTHORIZED();\n    }\n\n    /// @notice If the 'alsoGrantAccessIf' condition is truthy, proceed. Otherwise, require the message sender to be the\n    /// account or\n    /// have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    /// @param alsoGrantAccessIf An override condition which will allow access regardless of permissions.\n    function _requirePermissionAllowingOverrideFrom(\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool alsoGrantAccessIf\n    )\n        internal\n        view\n    {\n        if (alsoGrantAccessIf) return;\n        _requirePermissionFrom(account, projectId, permissionId);\n    }\n}\n"
			},
			"node_modules/@bananapus/core/src/enums/JBApprovalStatus.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A ruleset's approval status in a ruleset approval hook.\nenum JBApprovalStatus {\n    Empty,\n    Upcoming,\n    Active,\n    ApprovalExpected,\n    Approved,\n    Failed\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBController.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetConfig} from \"./../structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\nimport {JBRulesetWithMetadata} from \"./../structs/JBRulesetWithMetadata.sol\";\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {JBTerminalConfig} from \"./../structs/JBTerminalConfig.sol\";\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./IJBDirectoryAccessControl.sol\";\nimport {IJBFundAccessLimits} from \"./IJBFundAccessLimits.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBProjectUriRegistry} from \"./IJBProjectUriRegistry.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {IJBToken} from \"./IJBToken.sol\";\nimport {IJBTokens} from \"./IJBTokens.sol\";\n\ninterface IJBController is IERC165, IJBProjectUriRegistry, IJBDirectoryAccessControl {\n    event LaunchProject(uint256 rulesetId, uint256 projectId, string metadata, string memo, address caller);\n\n    event LaunchRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n\n    event QueueRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n\n    event SendReservedTokensToSplits(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address beneficiary,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        address caller\n    );\n\n    event SendReservedTokensToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed group,\n        JBSplit split,\n        uint256 tokenCount,\n        address caller\n    );\n\n    event MintTokens(\n        address indexed beneficiary,\n        uint256 indexed projectId,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        uint256 reservedRate,\n        address caller\n    );\n\n    event BurnTokens(\n        address indexed holder, uint256 indexed projectId, uint256 tokenCount, string memo, address caller\n    );\n\n    event ReservedDistributionReverted(\n        uint256 indexed projectId, JBSplit split, uint256 amount, bytes reason, address caller\n    );\n\n    event PrepMigration(uint256 indexed projectId, address from, address caller);\n\n    event SetMetadata(uint256 indexed projectId, string metadata, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n\n    function RULESETS() external view returns (IJBRulesets);\n\n    function TOKENS() external view returns (IJBTokens);\n\n    function SPLITS() external view returns (IJBSplits);\n\n    function FUND_ACCESS_LIMITS() external view returns (IJBFundAccessLimits);\n\n    function pendingReservedTokenBalanceOf(uint256 projectId) external view returns (uint256);\n\n    function totalTokenSupplyWithReservedTokensOf(uint256 projectId) external view returns (uint256);\n\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory, JBRulesetMetadata memory metadata, JBApprovalStatus);\n\n    function rulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRulesetWithMetadata[] memory rulesets);\n\n    function currentRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function upcomingRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function launchProjectFor(\n        address owner,\n        string calldata projectUri,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 projectId);\n\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n\n    function mintTokensOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary,\n        string calldata memo,\n        bool useReservedRate\n    )\n        external\n        returns (uint256 beneficiaryTokenCount);\n\n    function payReservedTokenToTerminal(\n        IJBTerminal terminal,\n        uint256 projectId,\n        IJBToken token,\n        uint256 splitAmount,\n        address beneficiary,\n        bytes calldata metadata\n    )\n        external;\n\n    function burnTokensOf(address holder, uint256 projectId, uint256 tokenCount, string calldata memo) external;\n\n    function sendReservedTokensToSplitsOf(uint256 projectId) external returns (uint256);\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] calldata splitGroups) external;\n\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n\n    function setTokenFor(uint256 _projectId, IJBToken _token) external;\n\n    function claimTokensFor(address holder, uint256 projectId, uint256 amount, address beneficiary) external;\n\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 amount) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBDirectory.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\ninterface IJBDirectory {\n    event SetController(uint256 indexed projectId, IERC165 indexed controller, address caller);\n\n    event AddTerminal(uint256 indexed projectId, IJBTerminal indexed terminal, address caller);\n\n    event SetTerminals(uint256 indexed projectId, IJBTerminal[] terminals, address caller);\n\n    event SetPrimaryTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed terminal, address caller\n    );\n\n    event SetIsAllowedToSetFirstController(address indexed addr, bool indexed flag, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function controllerOf(uint256 projectId) external view returns (IERC165);\n\n    function isAllowedToSetFirstController(address account) external view returns (bool);\n\n    function terminalsOf(uint256 projectId) external view returns (IJBTerminal[] memory);\n\n    function isTerminalOf(uint256 projectId, IJBTerminal terminal) external view returns (bool);\n\n    function primaryTerminalOf(uint256 projectId, address token) external view returns (IJBTerminal);\n\n    function setControllerOf(uint256 projectId, IERC165 controller) external;\n\n    function setTerminalsOf(uint256 projectId, IJBTerminal[] calldata terminals) external;\n\n    function setPrimaryTerminalOf(uint256 projectId, address token, IJBTerminal terminal) external;\n\n    function setIsAllowedToSetFirstController(address account, bool flag) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBDirectoryAccessControl.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBDirectoryAccessControl {\n    function setTerminalsAllowed(uint256 projectId) external view returns (bool);\n    function setControllerAllowed(uint256 projectId) external view returns (bool);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBFundAccessLimits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./../structs/JBCurrencyAmount.sol\";\nimport {JBFundAccessLimitGroup} from \"./../structs/JBFundAccessLimitGroup.sol\";\n\ninterface IJBFundAccessLimits {\n    event SetFundAccessLimits(\n        uint256 indexed rulesetId, uint256 indexed projectId, JBFundAccessLimitGroup limits, address caller\n    );\n\n    function payoutLimitsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory payoutLimits);\n\n    function payoutLimitOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 payoutLimit);\n\n    function surplusAllowancesOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory surplusAllowances);\n\n    function surplusAllowanceOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 surplusAllowance);\n\n    function setFundAccessLimitsFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBFundAccessLimitGroup[] memory fundAccessConstaints\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPayHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterPayRecordedContext} from \"./../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `pay(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBPayHook is IERC165 {\n    /// @notice This function is called by the terminal's `pay(...)` function after the payment has been recorded in the\n    /// terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterPayRecordedContext` struct.\n    function afterPayRecordedWith(JBAfterPayRecordedContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPermissions} from \"./IJBPermissions.sol\";\n\ninterface IJBPermissioned {\n    function PERMISSIONS() external view returns (IJBPermissions);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPermissions.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBPermissionsData} from \"./../structs/JBPermissionsData.sol\";\n\ninterface IJBPermissions {\n    event OperatorPermissionsSet(\n        address indexed operator,\n        address indexed account,\n        uint256 indexed projectId,\n        uint256[] permissionIds,\n        uint256 packed,\n        address caller\n    );\n\n    function WILDCARD_PROJECT_ID() external view returns (uint256);\n\n    function permissionsOf(address operator, address account, uint256 projectId) external view returns (uint256);\n\n    function hasPermission(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function hasPermissions(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256[] calldata permissionIds,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function setPermissionsFor(address account, JBPermissionsData calldata permissionsData) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPriceFeed.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBPriceFeed {\n    function currentUnitPrice(uint256 targetDecimals) external view returns (uint256);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPrices.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBPrices {\n    event AddPriceFeed(\n        uint256 indexed projectId, uint256 indexed pricingCurrency, uint256 indexed unitCurrency, IJBPriceFeed feed\n    );\n\n    function DEFAULT_PROJECT_ID() external view returns (uint256);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function priceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency\n    )\n        external\n        view\n        returns (IJBPriceFeed);\n\n    function pricePerUnitOf(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        uint256 decimals\n    )\n        external\n        view\n        returns (uint256);\n\n    function addPriceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed priceFeed\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBProjectUriRegistry.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBProjectUriRegistry {\n    function uriOf(uint256 projectId) external view returns (string memory);\n    function setUriOf(uint256 projectId, string calldata metadata) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBProjects.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {IJBTokenUriResolver} from \"./IJBTokenUriResolver.sol\";\n\ninterface IJBProjects is IERC721 {\n    event Create(uint256 indexed projectId, address indexed owner, address caller);\n\n    event SetTokenUriResolver(IJBTokenUriResolver indexed resolver, address caller);\n\n    function count() external view returns (uint256);\n\n    function tokenUriResolver() external view returns (IJBTokenUriResolver);\n\n    function createFor(address owner) external returns (uint256 projectId);\n\n    function setTokenUriResolver(IJBTokenUriResolver newResolver) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRedeemHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterRedeemRecordedContext} from \"./../structs/JBAfterRedeemRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `redeemTokensOf(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBRedeemHook is IERC165 {\n    /// @notice This function is called by the terminal's `redeemTokensOf(...)` function after the redemption has been\n    /// recorded in the terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterRedeemRecordedContext` struct.\n    function afterRedeemRecordedWith(JBAfterRedeemRecordedContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRedeemTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBAfterRedeemRecordedContext} from \"../structs/JBAfterRedeemRecordedContext.sol\";\nimport {IJBRedeemHook} from \"./IJBRedeemHook.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\n/// @notice A terminal that can be redeemed from.\ninterface IJBRedeemTerminal is IJBTerminal {\n    event RedeemTokens(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address holder,\n        address beneficiary,\n        uint256 tokenCount,\n        uint256 redemptionRate,\n        uint256 reclaimedAmount,\n        bytes metadata,\n        address caller\n    );\n\n    event HookAfterRecordRedeem(\n        IJBRedeemHook indexed hook,\n        JBAfterRedeemRecordedContext context,\n        uint256 specificationAmount,\n        uint256 fee,\n        address caller\n    );\n\n    function redeemTokensOf(\n        address holder,\n        uint256 projectId,\n        address tokenToReclaim,\n        uint256 redeemCount,\n        uint256 minTokensReclaimed,\n        address payable beneficiary,\n        bytes calldata metadata\n    )\n        external\n        returns (uint256 reclaimAmount);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\n\n/// @notice `IJBRulesetApprovalHook`s are used to determine whether the next ruleset in the ruleset queue is approved or\n/// rejected.\n/// @dev Project rulesets are stored in a queue. Rulesets take effect after the previous ruleset in the queue ends, and\n/// only if they are approved by the previous ruleset's approval hook.\ninterface IJBRulesetApprovalHook is IERC165 {\n    function DURATION() external view returns (uint256);\n\n    function approvalStatusOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 start\n    )\n        external\n        view\n        returns (JBApprovalStatus);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesets.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {IJBRulesetApprovalHook} from \"./IJBRulesetApprovalHook.sol\";\n\ninterface IJBRulesets {\n    event RulesetQueued(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 decayRate,\n        IJBRulesetApprovalHook hook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter,\n        address caller\n    );\n\n    event RulesetInitialized(uint256 indexed rulesetId, uint256 indexed projectId, uint256 indexed basedOnId);\n\n    function latestRulesetIdOf(uint256 projectId) external view returns (uint256);\n\n    function getRulesetOf(uint256 projectId, uint256 rulesetId) external view returns (JBRuleset memory);\n\n    function latestQueuedOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus);\n\n    function rulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRuleset[] memory rulesets);\n\n    function upcomingOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function currentOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId) external view returns (JBApprovalStatus);\n\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 decayRate,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        returns (JBRuleset memory ruleset);\n\n    function updateRulesetWeightCache(uint256 projectId) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBSplitHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBSplitHookContext} from \"../structs/JBSplitHookContext.sol\";\n\n/// @title Split hook\n/// @notice Allows processing a single split with custom logic.\n/// @dev The split hook's address should be set as the `hook` in the relevant split.\ninterface IJBSplitHook is IERC165 {\n    /// @notice If a split has a split hook, payment terminals and controllers call this function while processing the\n    /// split.\n    /// @dev Critical business logic should be protected by appropriate access control. The tokens and/or native tokens\n    /// are optimistically transferred to the split hook when this function is called.\n    /// @param context The context passed by the terminal/controller to the split hook as a `JBSplitHookContext` struct:\n    function processSplitWith(JBSplitHookContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBSplits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBSplits {\n    event SetSplit(\n        uint256 indexed projectId, uint256 indexed rulesetId, uint256 indexed group, JBSplit split, address caller\n    );\n\n    function FALLBACK_RULESET_ID() external view returns (uint256);\n\n    function splitsOf(uint256 projectId, uint256 rulesetId, uint256 group) external view returns (JBSplit[] memory);\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] memory splitGroups) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAccountingContext} from \"../structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"../structs/JBAfterPayRecordedContext.sol\";\nimport {IJBPayHook} from \"../interfaces/IJBPayHook.sol\";\n\n/// @notice A terminal that accepts payments and can be migrated.\ninterface IJBTerminal is IERC165 {\n    event MigrateTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed to, uint256 amount, address caller\n    );\n\n    event AddToBalance(\n        uint256 indexed projectId, uint256 amount, uint256 unlockedFees, string memo, bytes metadata, address caller\n    );\n\n    event SetAccountingContext(\n        uint256 indexed projectId, address indexed token, JBAccountingContext context, address caller\n    );\n\n    event Pay(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address payer,\n        address beneficiary,\n        uint256 amount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        bytes metadata,\n        address caller\n    );\n\n    event HookAfterRecordPay(\n        IJBPayHook indexed hook, JBAfterPayRecordedContext context, uint256 specificationAmount, address caller\n    );\n\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        returns (JBAccountingContext memory);\n\n    function accountingContextsOf(uint256 projectId) external view returns (JBAccountingContext[] memory);\n\n    function currentSurplusOf(uint256 projectId, uint256 decimals, uint256 currency) external view returns (uint256);\n\n    function migrateBalanceOf(uint256 projectId, address token, IJBTerminal to) external returns (uint256 balance);\n\n    function addAccountingContextsFor(uint256 projectId, address[] calldata tokens) external;\n\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        returns (uint256 beneficiaryTokenCount);\n\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBToken.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBToken {\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function mint(address account, uint256 amount) external;\n\n    function burn(address account, uint256 amount) external;\n\n    function initialize(string memory name, string memory symbol, address owner) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTokenUriResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBTokenUriResolver {\n    function getUri(uint256 projectId) external view returns (string memory tokenUri);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTokens.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBToken} from \"./IJBToken.sol\";\n\ninterface IJBTokens {\n    event DeployERC20(\n        uint256 indexed projectId, IJBToken indexed token, string name, string symbol, bytes32 salt, address caller\n    );\n\n    event Mint(\n        address indexed holder, uint256 indexed projectId, uint256 amount, bool tokensWereClaimed, address caller\n    );\n\n    event Burn(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 amount,\n        uint256 initialCreditBalance,\n        uint256 initialTokenBalance,\n        address caller\n    );\n\n    event ClaimTokens(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 initialCreditBalance,\n        uint256 amount,\n        address beneficiary,\n        address caller\n    );\n\n    event SetToken(uint256 indexed projectId, IJBToken indexed newToken, address caller);\n\n    event TransferCredits(\n        address indexed holder, uint256 indexed projectId, address indexed recipient, uint256 amount, address caller\n    );\n\n    function tokenOf(uint256 projectId) external view returns (IJBToken);\n\n    function projectIdOf(IJBToken token) external view returns (uint256);\n\n    function creditBalanceOf(address holder, uint256 projectId) external view returns (uint256);\n\n    function totalCreditSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalBalanceOf(address holder, uint256 projectId) external view returns (uint256 result);\n\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n\n    function burnFrom(address holder, uint256 projectId, uint256 amount) external;\n\n    function mintFor(address holder, uint256 projectId, uint256 amount) external;\n\n    function claimTokensFor(address holder, uint256 projectId, uint256 amount, address beneficiary) external;\n\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 amount) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBConstants.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Global constants used across Juicebox contracts.\nlibrary JBConstants {\n    /// @notice Each chain's native token address in Juicebox is represented by\n    /// 0x000000000000000000000000000000000000EEEe.\n    address public constant NATIVE_TOKEN = address(0x000000000000000000000000000000000000EEEe);\n    uint256 public constant MAX_RESERVED_RATE = 10_000;\n    uint256 public constant MAX_REDEMPTION_RATE = 10_000;\n    uint256 public constant MAX_DECAY_RATE = 1_000_000_000;\n    uint256 public constant SPLITS_TOTAL_PERCENT = 1_000_000_000;\n    uint256 public constant MAX_FEE = 1000;\n    uint256 public constant MAX_FEE_DISCOUNT = 1_000_000_000;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAccountingContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The address of the token that accounting is being done with.\n/// @custom:member decimals The number of decimals expected in that token's fixed point accounting.\n/// @custom:member currency The currency that the token is priced in terms of. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBAccountingContext {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAfterPayRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member payer The address the payment originated from.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member amount The payment's token amount. Includes the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the pay hook. Includes the token\n/// being paid, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member weight The current ruleset's weight (used to determine how many tokens should be minted).\n/// @custom:member projectTokenCount The number of project tokens minted for the beneficiary.\n/// @custom:member beneficiary The address which receives any tokens this payment yields.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the pay hook.\n/// @custom:member payerMetadata Extra data specified by the payer, which is sent to the pay hook.\nstruct JBAfterPayRecordedContext {\n    address payer;\n    uint256 projectId;\n    uint256 rulesetId;\n    JBTokenAmount amount;\n    JBTokenAmount forwardedAmount;\n    uint256 weight;\n    uint256 projectTokenCount;\n    address beneficiary;\n    bytes hookMetadata;\n    bytes payerMetadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAfterRedeemRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member holder The holder of the tokens being redeemed.\n/// @custom:member projectId The ID of the project being redeemed from.\n/// @custom:member rulesetId The ID of the ruleset the redemption is being made during.\n/// @custom:member redeemCount The number of project tokens being redeemed.\n/// @custom:member redemptionRate The current ruleset's redemption rate.\n/// @custom:member reclaimedAmount The token amount being reclaimed from the project's terminal balance. Includes the\n/// token being\n/// reclaimed, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the redeem hook. Includes the token\n/// being forwarded, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member beneficiary The address the reclaimed amount will be sent to.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the redeem hook.\n/// @custom:member redeemerMetadata Extra data specified by the redeemer, which is sent to the redeem hook.\nstruct JBAfterRedeemRecordedContext {\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 redeemCount;\n    JBTokenAmount reclaimedAmount;\n    JBTokenAmount forwardedAmount;\n    uint256 redemptionRate;\n    address payable beneficiary;\n    bytes hookMetadata;\n    bytes redeemerMetadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBCurrencyAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member amount The amount of the currency.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBCurrencyAmount {\n    uint256 amount;\n    uint256 currency;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBFundAccessLimitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./JBCurrencyAmount.sol\";\n\n/// @dev Payout limit example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH, then\n/// the project can pay out 5 USD worth of ETH during a ruleset.\n/// @dev Surplus allowance example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH,\n/// then the project can pay out 5 USD worth of ETH from its surplus during a ruleset. A project's surplus is its\n/// balance minus its current combined payout limit.\n/// @dev If a project has multiple payout limits or surplus allowances, they are all available. They can all be used\n/// during a single ruleset.\n/// @dev The payout limits' and surplus allowances' fixed point amounts have the same number of decimals as the\n/// terminal.\n/// @custom:member terminal The terminal that the payout limits and surplus allowances apply to.\n/// @custom:member token The token that the payout limits and surplus allowances apply to within the `terminal`.\n/// @custom:member payoutLimits An array of payout limits. The payout limits cumulatively dictate the maximum value of\n/// `token`s a project can pay out from its balance in a terminal during a ruleset. Each payout limit can have a unique\n/// currency and amount.\n/// @custom:member surplusAllowances An array of surplus allowances. The surplus allowances cumulatively dictates the\n/// maximum value of `token`s a project can pay out from its surplus (balance less payouts) in a terminal during a\n/// ruleset. Each surplus allowance can have a unique currency and amount.\nstruct JBFundAccessLimitGroup {\n    address terminal;\n    address token;\n    JBCurrencyAmount[] payoutLimits;\n    JBCurrencyAmount[] surplusAllowances;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBPermissionsData.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member operator The address that permissions are being given to.\n/// @custom:member projectId The ID of the project the operator is being given permissions for. Operators only have\n/// permissions under this project's scope. An ID of 0 is a wildcard, which gives an operator permissions across all\n/// projects.\n/// @custom:member permissionIds The IDs of the permissions being given. See the `JBPermissionIds` library.\nstruct JBPermissionsData {\n    address operator;\n    uint256 projectId;\n    uint256[] permissionIds;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRuleset.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"./../interfaces/IJBRulesetApprovalHook.sol\";\n\n/// @dev `JBRuleset` timestamps are unix timestamps (seconds since 00:00 January 1st, 1970 UTC).\n/// @custom:member cycleNumber The ruleset's cycle number. Each ruleset's `cycleNumber` is the previous ruleset's\n/// `cycleNumber` plus one. Each project's first ruleset has a `cycleNumber` of 1.\n/// @custom:member id The ruleset's ID, which is a timestamp of when this ruleset's rules were initialized. The\n/// `rulesetId` stays the same for rulesets that automatically cycle over from a manually queued ruleset.\n/// @custom:member basedOnId The `rulesetId` of the ruleset which was active when this ruleset was created.\n/// @custom:member start The timestamp from which this ruleset is considered active.\n/// @custom:member duration The number of seconds the ruleset lasts for. After this duration, a new ruleset will start.\n/// The project owner can queue new rulesets at any time, which will take effect once the current ruleset's duration is\n/// over. If the `duration` is 0, newly queued rulesets will take effect immediately. If a ruleset ends and there are no\n/// new rulesets queued, the current ruleset cycles over to another one with the same properties but a new `start`\n/// timestamp and a `weight` reduced by the ruleset's `decayRate`.\n/// @custom:member weight A fixed point number with 18 decimals which is typically used by payment terminals to\n/// determine how many tokens should be minted when a payment is received. This can be used by other contracts for\n/// arbitrary calculations.\n/// @custom:member decayRate The percentage by which to reduce the `weight` each time a new ruleset starts. `weight` is\n/// a percentage out of `JBConstants.MAX_DECAY_RATE`. If it's 0, the next ruleset will have the same `weight` by\n/// default. If it's 90%, the next ruleset's `weight` will be 10% smaller. If a ruleset explicitly sets a new `weight`,\n/// the `decayRate` doesn't apply.\n/// @custom:member approvalHook An address of a contract that says whether a queued ruleset should be approved or\n/// rejected. If a\n/// ruleset is rejected, it won't go into effect. An approval hook can be used to create rules which dictate how a\n/// project owner can change their ruleset over time.\n/// @custom:member metadata Extra data associated with a ruleset which can be used by other contracts.\nstruct JBRuleset {\n    uint256 cycleNumber;\n    uint256 id;\n    uint256 basedOnId;\n    uint256 start;\n    uint256 duration;\n    uint256 weight;\n    uint256 decayRate;\n    IJBRulesetApprovalHook approvalHook;\n    uint256 metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"../interfaces/IJBRulesetApprovalHook.sol\";\nimport {JBFundAccessLimitGroup} from \"./JBFundAccessLimitGroup.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\nimport {JBSplitGroup} from \"./JBSplitGroup.sol\";\n\n/// @custom:member mustStartAtOrAfter The earliest time the ruleset can start.\n/// @custom:member duration The number of seconds the ruleset lasts for, after which a new ruleset will start. A\n/// duration of 0 means that the ruleset will stay active until the project owner explicitly issues a reconfiguration,\n/// at which point a new ruleset will immediately start with the updated properties. If the duration is greater than 0,\n/// a project owner cannot make changes to a ruleset's parameters while it is active – any proposed changes will apply\n/// to the subsequent ruleset. If no changes are proposed, a ruleset rolls over to another one with the same properties\n/// but new `start` timestamp and a decayed `weight`.\n/// @custom:member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations\n/// on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is\n/// received.\n/// @custom:member decayRate A percent by how much the `weight` of the subsequent ruleset should be reduced, if the\n/// project owner hasn't queued the subsequent ruleset with an explicit `weight`. If it's 0, each ruleset will have\n/// equal weight. If the number is 90%, the next ruleset will have a 10% smaller weight. This weight is out of\n/// `JBConstants.MAX_DECAY_RATE`.\n/// @custom:member approvalHook An address of a contract that says whether a proposed ruleset should be accepted or\n/// rejected. It\n/// can be used to create rules around how a project owner can change ruleset parameters over time.\n/// @custom:member metadata Metadata specifying the controller-specific parameters that a ruleset can have. These\n/// properties cannot change until the next ruleset starts.\n/// @custom:member splitGroups An array of splits to use for any number of groups while the ruleset is active.\n/// @custom:member fundAccessLimitGroups An array of structs which dictate the amount of funds a project can access from\n/// its balance in each payment terminal while the ruleset is active. Amounts are fixed point numbers using the same\n/// number of decimals as the corresponding terminal. The `_payoutLimit` and `_surplusAllowance` parameters must fit in\n/// a `uint232`.\nstruct JBRulesetConfig {\n    uint256 mustStartAtOrAfter;\n    uint256 duration;\n    uint256 weight;\n    uint256 decayRate;\n    IJBRulesetApprovalHook approvalHook;\n    JBRulesetMetadata metadata;\n    JBSplitGroup[] splitGroups;\n    JBFundAccessLimitGroup[] fundAccessLimitGroups;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member reservedRate The reserved rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_RESERVED_RATE`.\n/// @custom:member redemptionRate The redemption rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_REDEMPTION_RATE`.\n/// @custom:member baseCurrency The currency on which to base the ruleset's weight. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member pausePay A flag indicating if the pay functionality should be paused during the ruleset.\n/// @custom:member pauseCreditTransfers A flag indicating if the project token transfer functionality should be paused\n/// during the funding cycle.\n/// @custom:member allowOwnerMinting A flag indicating if the project owner or an operator with the `MINT_TOKENS`\n/// permission from the owner should be allowed to mint project tokens on demand during this ruleset.\n/// @custom:member allowTerminalMigration A flag indicating if migrating terminals should be allowed during this\n/// ruleset.\n/// @custom:member allowSetTerminals A flag indicating if a project's terminals can be added or removed.\n/// @custom:member allowSetController A flag indicating if a project's controller can be changed.\n/// @custom:member ownerMustSendPayouts A flag indicating if privileged payout distribution should be\n/// enforced, otherwise payouts can be distributed by anyone.\n/// @custom:member holdFees A flag indicating if fees should be held during this ruleset.\n/// @custom:member useTotalSurplusForRedemptions A flag indicating if redemptions should use the project's balance held\n/// in all terminals instead of the project's local terminal balance from which the redemption is being fulfilled.\n/// @custom:member useDataHookForPay A flag indicating if the data hook should be used for pay transactions during this\n/// ruleset.\n/// @custom:member useDataHookForRedeem A flag indicating if the data hook should be used for redeem transactions during\n/// this ruleset.\n/// @custom:member dataHook The data hook to use during this ruleset.\n/// @custom:member metadata Metadata of the metadata, up to uint8 in size.\nstruct JBRulesetMetadata {\n    uint256 reservedRate;\n    uint256 redemptionRate;\n    uint256 baseCurrency;\n    bool pausePay;\n    bool pauseCreditTransfers;\n    bool allowOwnerMinting;\n    bool allowSetCustomToken;\n    bool allowTerminalMigration;\n    bool allowSetTerminals;\n    bool allowSetController;\n    bool ownerMustSendPayouts;\n    bool holdFees;\n    bool useTotalSurplusForRedemptions;\n    bool useDataHookForPay;\n    bool useDataHookForRedeem;\n    address dataHook;\n    uint256 metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetWithMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBRuleset} from \"./JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\n\n/// @custom:member ruleset The ruleset.\n/// @custom:member metadata The ruleset's metadata.\nstruct JBRulesetWithMetadata {\n    JBRuleset ruleset;\n    JBRulesetMetadata metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplit.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSplitHook} from \"./../interfaces/IJBSplitHook.sol\";\n\n/// @notice Splits are used to send a percentage of a total token amount to a specific contract, project, or address.\n/// Splits are used to send payouts and reserved tokens.\n/// @dev 1. If a non-zero split hook contract is specified, this split's tokens are sent there along with this split's\n/// properties.\n/// @dev 2. Otherwise, if a non-zero project ID is specified, this split's tokens are used to `pay` it through its\n/// terminal if possible, or sent to the project's owner if not. If this payment yields tokens, those go to the split's\n/// `beneficiary`.\n/// @dev 3. Otherwise, this split's tokens are sent directly to the `beneficiary`.\n/// @dev To summarize, this split's tokens are sent according to the following priority: `split hook` > `projectId` >\n/// `beneficiary`.\n/// @custom:member preferAddToBalance If this split were to `pay` a project through its terminal, this flag indicates\n/// whether it should prefer using the terminal's `addToBalance` function instead.\n/// @custom:member percent The percent of the total token amount that this split sends. This number is out of\n/// `JBConstants.SPLITS_TOTAL_PERCENT`.\n/// @custom:member projectId The ID of a project to `pay`, if applicable. Resulting tokens will be routed to the\n/// `beneficiary`.\n/// @custom:member beneficiary Receives this split's tokens if the `hook` and `projectId` are zero. If the `projectId`\n/// is specified, the `beneficiary` receives any project tokens minted by this split.\n/// @custom:member lockedUntil The split cannot be changed until this timestamp. The `lockedUntil` timestamp can be\n/// increased while a split is locked. If `lockedUntil` is zero, this split can be changed at any time.\n/// @custom:member hook A contract which will receive this split's tokens and properties, and can define custom\n/// behavior.\nstruct JBSplit {\n    bool preferAddToBalance;\n    uint256 percent;\n    uint256 projectId;\n    address payable beneficiary;\n    uint256 lockedUntil;\n    IJBSplitHook hook;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member groupId An identifier for the group. By convention, this ID is `uint256(uint160(tokenAddress))` for\n/// payouts and `1` for reserved tokens.\n/// @custom:member splits The splits in the group.\nstruct JBSplitGroup {\n    uint256 groupId;\n    JBSplit[] splits;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplitHookContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member token The token being sent to the split hook.\n/// @custom:member amount The amount being sent to the split hook, as a fixed point number.\n/// @custom:member decimals The number of decimals in the amount.\n/// @custom:member projectId The project the split belongs to.\n/// @custom:member groupId The group the split belongs to. By convention, this ID is `uint256(uint160(tokenAddress))`\n/// for payouts and `1` for reserved tokens.\n/// @custom:member split The split which specified the hook.\nstruct JBSplitHookContext {\n    address token;\n    uint256 amount;\n    uint256 decimals;\n    uint256 projectId;\n    uint256 groupId;\n    JBSplit split;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBTerminalConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBTerminal} from \"./../interfaces/IJBTerminal.sol\";\n\n/// @custom:member terminal The terminal to configure.\n/// @custom:member acceptedTokens The tokens to accept from the terminal.\nstruct JBTerminalConfig {\n    IJBTerminal terminal;\n    address[] tokensToAccept;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBTokenAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The token the payment was made in.\n/// @custom:member value The amount of tokens that was paid, as a fixed point number.\n/// @custom:member decimals The number of decimals included in the value fixed point number.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBTokenAmount {\n    address token;\n    uint256 value;\n    uint256 decimals;\n    uint256 currency;\n}\n"
			},
			"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Permission IDs for `JBPermissions`, used throughout the Bananapus ecosystem. See\n/// https://github.com/Bananapus/nana-core/blob/main/src/JBPermissions.sol\n/// @dev `JBPermissions` allows one address to grant another address permission to call functions in Juicebox contracts\n/// on their behalf. Each ID in `JBPermissionIds` grants access to a specific set of these functions.\nlibrary JBPermissionIds {\n    uint256 internal constant ROOT = 1; // All permissions across every contract. Very dangerous. BE CAREFUL!\n\n    /* Used by `nana-core`: https://github.com/Bananapus/nana-core */\n    uint256 internal constant QUEUE_RULESETS = 2; // Permission to call `JBController.queueRulesetsOf` and\n        // `JBController.launchRulesetsFor`.\n    uint256 internal constant REDEEM_TOKENS = 3; // Permission to call `JBMultiTerminal.redeemTokensOf`.\n    uint256 internal constant SEND_PAYOUTS = 4; // Permission to call `JBMultiTerminal.sendPayoutsOf`.\n    uint256 internal constant MIGRATE_TERMINAL = 5; // Permission to call `JBMultiTerminal.migrateBalanceOf`.\n    uint256 internal constant SET_PROJECT_METADATA = 6; // Permission to call `JBController.setUriOf`.\n    uint256 internal constant DEPLOY_ERC20 = 7; // Permission to call `JBController.deployERC20For`.\n    uint256 internal constant SET_TOKEN = 8; // Permission to call `JBController.setTokenFor`.\n    uint256 internal constant MINT_TOKENS = 9; // Permission to call `JBController.mintTokensOf`.\n    uint256 internal constant BURN_TOKENS = 10; // Permission to call `JBController.burnTokensOf`.\n    uint256 internal constant CLAIM_TOKENS = 11; // Permission to call `JBController.claimTokensFor`.\n    uint256 internal constant TRANSFER_CREDITS = 12; // Permission to call `JBController.transferCreditsFrom`.\n    uint256 internal constant SET_CONTROLLER = 13; // Permission to call `JBDirectory.setControllerOf`.\n    uint256 internal constant SET_TERMINALS = 14; // Permission to call `JBDirectory.setTerminalsOf`.\n    uint256 internal constant SET_PRIMARY_TERMINAL = 15; // Permission to call `JBDirectory.setPrimaryTerminalOf`.\n    uint256 internal constant USE_ALLOWANCE = 16; // Permission to call `JBMultiTerminal.useAllowanceOf`.\n    uint256 internal constant SET_SPLIT_GROUPS = 17; // Permission to call `JBController.setSplitGroupsOf`.\n    uint256 internal constant ADD_PRICE_FEED = 18; // Permission to call `JBPrices.addPriceFeedFor`.\n    uint256 internal constant ADD_ACCOUNTING_CONTEXTS = 19; // Permission to call\n        // `JBMultiTerminal.addAccountingContextsFor`.\n\n    /* Used by `nana-721-hook`: https://github.com/Bananapus/nana-721-hook */\n    uint256 internal constant ADJUST_721_TIERS = 20; // Permission to call `JB721TiersHook.adjustTiers`.\n    uint256 internal constant SET_721_METADATA = 21; // Permission to call `JB721TiersHook.setMetadata`.\n    uint256 internal constant MINT_721 = 22; // Permission to call `JB721TiersHook.mintFor`.\n\n    /* Used by `nana-buyback-hook`: https://github.com/Bananapus/nana-buyback-hook */\n    uint256 internal constant SET_BUYBACK_TWAP = 23; // Permission to call `JBBuybackHook.setTwapWindowOf` and\n        // `JBBuybackHook.setTwapSlippageToleranceOf`.\n    uint256 internal constant SET_BUYBACK_POOL = 24; // Permission to call `JBBuybackHook.setPoolFor`.\n\n    /* Used by `nana-swap-terminal`: https://github.com/Bananapus/nana-swap-terminal */\n    uint256 internal constant ADD_SWAP_TERMINAL_POOL = 25; // Permission to call `JBSwapTerminal.addDefaultPool`.\n    uint256 internal constant ADD_SWAP_TERMINAL_TWAP_PARAMS = 26; // Permission to call\n        // `JBSwapTerminal.addTwapParamsFor`.\n\n    /* Used by `nana-suckers`: https://github.com/Bananapus/nana-suckers */\n    uint256 internal constant MAP_SUCKER_TOKEN = 27; // Permission to call `BPSucker.mapToken`.\n    uint256 internal constant DEPLOY_SUCKERS = 28; // Permission to call `BPSuckerRegistry.deploySuckersFor`.\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Address.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/structs/BitMaps.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/BitMaps.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, provided the keys are sequential.\n * Largely inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\n *\n * BitMaps pack 256 booleans across each bit of a single 256-bit slot of `uint256` type.\n * Hence booleans corresponding to 256 _sequential_ indices would only consume a single slot,\n * unlike the regular `bool` which would consume an entire slot for a single value.\n *\n * This results in gas savings in two ways:\n *\n * - Setting a zero value to non-zero only once every 256 times\n * - Accessing the same warm slot for every 256 _sequential_ indices\n */\nlibrary BitMaps {\n    struct BitMap {\n        mapping(uint256 bucket => uint256) _data;\n    }\n\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index` to the boolean `value`.\n     */\n    function setTo(BitMap storage bitmap, uint256 index, bool value) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    /**\n     * @dev Unsets the bit at `index`.\n     */\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }\n}\n"
			},
			"src/BPOptimismSucker.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BitMaps} from \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\nimport {IJBRulesets} from \"@bananapus/core/src/interfaces/IJBRulesets.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBTokens} from \"@bananapus/core/src/interfaces/IJBTokens.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {JBConstants} from \"@bananapus/core/src/libraries/JBConstants.sol\";\n\nimport {BPSucker, IBPSuckerDeployer, BPAddToBalanceMode} from \"./BPSucker.sol\";\nimport {BPMessageRoot} from \"./structs/BPMessageRoot.sol\";\nimport {BPRemoteToken} from \"./structs/BPRemoteToken.sol\";\nimport {BPInboxTreeRoot} from \"./structs/BPInboxTreeRoot.sol\";\nimport {BPOptimismSuckerDeployer} from \"./deployers/BPOptimismSuckerDeployer.sol\";\nimport {OPMessenger} from \"./interfaces/OPMessenger.sol\";\nimport {OPStandardBridge} from \"./interfaces/OPStandardBridge.sol\";\nimport {MerkleLib} from \"./utils/MerkleLib.sol\";\n\n/// @notice A `BPSucker` implementation to suck tokens between two chains connected by an OP Bridge.\ncontract BPOptimismSucker is BPSucker {\n    using MerkleLib for MerkleLib.Tree;\n    using BitMaps for BitMaps.BitMap;\n\n    event SuckingToRemote(address token, uint64 nonce);\n\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    /// @notice The messenger used to send messages between the local and remote sucker.\n    OPMessenger public immutable OPMESSENGER;\n\n    /// @notice The bridge used to bridge tokens between the local and remote chain.\n    OPStandardBridge public immutable OPBRIDGE;\n\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n\n    constructor(\n        IJBDirectory directory,\n        IJBTokens tokens,\n        IJBPermissions permissions,\n        address peer,\n        BPAddToBalanceMode atbMode\n    ) BPSucker(directory, tokens, permissions, peer, atbMode, IBPSuckerDeployer(msg.sender).TEMP_ID_STORE()) {\n        // Fetch the messenger and bridge by doing a callback to the deployer contract.\n        OPMESSENGER = BPOptimismSuckerDeployer(msg.sender).MESSENGER();\n        OPBRIDGE = BPOptimismSuckerDeployer(msg.sender).BRIDGE();\n    }\n\n    //*********************************************************************//\n    // ------------------------ external views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Returns the chain on which the peer is located.\n    /// @return chainId of the peer.\n    function peerChainID() external view virtual override returns (uint256 chainId) {\n        uint256 _localChainId = block.chainid;\n        if (_localChainId == 1) return 10;\n        if (_localChainId == 10) return 1;\n        if (_localChainId == 11155111) return 11155420;\n        if (_localChainId == 11155420) return 11155111;\n    }\n\n    //*********************************************************************//\n    // --------------------- internal transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Use the `OPMESSENGER` to send the outbox tree for the `token` and the corresponding funds to the peer over the `OPBRIDGE`.\n    /// @param transportPayment the amount of `msg.value` that is going to get paid for sending this message.\n    /// @param token The token to bridge the outbox tree for.\n    /// @param remoteToken Information about the remote token being bridged to.\n    function _sendRoot(uint256 transportPayment, address token, BPRemoteToken memory remoteToken) internal override {\n        uint256 nativeValue;\n\n        // Revert if there's a `msg.value`. The OP bridge does not expect to be paid.\n        if (transportPayment != 0) {\n            revert UNEXPECTED_MSG_VALUE();\n        }\n\n        // Get the amount to send and then clear it from the outbox tree.\n        uint256 amount = outbox[token].balance;\n        delete outbox[token].balance;\n\n        // Increment the outbox tree's nonce.\n        uint64 nonce = ++outbox[token].nonce;\n\n        // Ensure the token is mapped to an address on the remote chain.\n        if (remoteToken.addr == address(0)) {\n            revert TOKEN_NOT_MAPPED(token);\n        }\n\n        // If the token is an ERC20, bridge it to the peer.\n        if (token != JBConstants.NATIVE_TOKEN) {\n            // Approve the tokens bing bridged.\n            SafeERC20.forceApprove(IERC20(token), address(OPBRIDGE), amount);\n\n            // Bridge the tokens to the peer sucker.\n            OPBRIDGE.bridgeERC20To({\n                localToken: token,\n                remoteToken: remoteToken.addr,\n                to: PEER,\n                amount: amount,\n                minGasLimit: remoteToken.minGas,\n                extraData: bytes(\"\")\n            });\n        } else {\n            // Otherwise, the token is the native token, and the amount will be sent as `msg.value`.\n            nativeValue = amount;\n        }\n\n        bytes32 _root = outbox[token].tree.root();\n        uint256 _index = outbox[token].tree.count - 1;\n\n        // Send the message to the peer with the redeemed ETH.\n        // slither-disable-next-line arbitrary-send-eth\n        OPMESSENGER.sendMessage{value: nativeValue}(\n            PEER,\n            abi.encodeCall(\n                BPSucker.fromRemote,\n                (\n                    BPMessageRoot({\n                        token: remoteToken.addr,\n                        amount: amount,\n                        remoteRoot: BPInboxTreeRoot({nonce: nonce, root: _root})\n                    })\n                )\n            ),\n            MESSENGER_BASE_GAS_LIMIT\n        );\n\n        // Emit an event for the relayers to watch for.\n        emit RootToRemote(_root, token, _index, nonce);\n    }\n\n    /// @notice Checks if the `sender` (`msg.sender`) is a valid representative of the remote peer.\n    /// @param sender The message's sender.\n    function _isRemotePeer(address sender) internal override returns (bool valid) {\n        return sender == address(OPMESSENGER) && OPMESSENGER.xDomainMessageSender() == PEER;\n    }\n}\n"
			},
			"src/BPSucker.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IBPSucker} from \"./interfaces/IBPSucker.sol\";\nimport {IBPSuckerDeployer} from \"./interfaces/IBPSuckerDeployer.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBTokens} from \"@bananapus/core/src/interfaces/IJBTokens.sol\";\nimport {IJBTerminal} from \"@bananapus/core/src/interfaces/IJBTerminal.sol\";\nimport {IJBRedeemTerminal} from \"@bananapus/core/src/interfaces/IJBRedeemTerminal.sol\";\nimport {JBConstants} from \"@bananapus/core/src/libraries/JBConstants.sol\";\nimport {JBPermissioned} from \"@bananapus/core/src/abstract/JBPermissioned.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BitMaps} from \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\n\nimport {BPTokenMapping} from \"./structs/BPTokenMapping.sol\";\nimport {BPRemoteToken} from \"./structs/BPRemoteToken.sol\";\nimport {BPOutboxTree} from \"./structs/BPOutboxTree.sol\";\nimport {BPInboxTreeRoot} from \"./structs/BPInboxTreeRoot.sol\";\nimport {BPMessageRoot} from \"./structs/BPMessageRoot.sol\";\nimport {BPClaim} from \"./structs/BPClaim.sol\";\nimport {BPAddToBalanceMode} from \"./enums/BPAddToBalanceMode.sol\";\nimport {MerkleLib} from \"./utils/MerkleLib.sol\";\n\n/// @notice An abstract contract for bridging a Juicebox project's tokens and the corresponding funds to and from a remote chain.\n/// @dev Beneficiaries and balances are tracked on two merkle trees: the outbox tree is used to send from the local chain to the remote chain, and the inbox tree is used to receive from the remote chain to the local chain.\n/// @dev Throughout this contract, \"terminal token\" refers to any token accepted by a project's terminal.\n/// @dev This contract does *NOT* support tokens that have a fee on regular transfers and rebasing tokens.\nabstract contract BPSucker is JBPermissioned, IBPSucker {\n    using MerkleLib for MerkleLib.Tree;\n    using BitMaps for BitMaps.BitMap;\n    using SafeERC20 for IERC20;\n\n    /// @notice The depth of the merkle tree used to track beneficiaries, token balances, and redemption values.\n    uint256 internal constant TREE_DEPTH = 32;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error NOT_PEER();\n    error BELOW_MIN_GAS(uint256 minGas, uint256 suppliedGas);\n    error ERC20_TOKEN_REQUIRED();\n    error BENEFICIARY_NOT_ALLOWED();\n    error NO_TERMINAL_FOR(uint256 projectId, address token);\n    error INVALID_PROOF(bytes32 expectedRoot, bytes32 proofRoot);\n    error INVALID_NATIVE_REMOTE_ADDRESS(address addr);\n    error LEAF_ALREADY_EXECUTED(uint256 index);\n    error QUEUE_INSUFFECIENT_SIZE(uint256 minSize, uint256 currentSize);\n    error INSUFFICIENT_BALANCE();\n    error TOKEN_NOT_MAPPED(address token);\n    error MANUAL_NOT_ALLOWED();\n    error UNEXPECTED_MSG_VALUE();\n\n    //*********************************************************************//\n    // ---------------------- public stored properties ------------------- //\n    //*********************************************************************//\n\n    /// @notice The outbox merkle tree for a given token.\n    mapping(address token => BPOutboxTree) public outbox;\n\n    /// @notice The inbox merkle tree root for a given token.\n    mapping(address token => BPInboxTreeRoot root) public inbox;\n\n    /// @notice The outstanding amount of tokens to be added to the project's balance by `claim` or `addOutstandingAmountToBalance`.\n    mapping(address token => uint256 amount) public amountToAddToBalance;\n\n    /// @notice Information about the token on the remote chain that the given token on the local chain is mapped to.\n    mapping(address token => BPRemoteToken remoteToken) public remoteTokenFor;\n\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    /// @notice Whether the `amountToAddToBalance` gets added to the project's balance automatically when `claim` is called or manually by calling `addOutstandingAmountToBalance`.\n    BPAddToBalanceMode public immutable ADD_TO_BALANCE_MODE;\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory public immutable DIRECTORY;\n\n    /// @notice The contract that manages token minting and burning.\n    IJBTokens public immutable TOKENS;\n\n    /// @notice The address of this contract's deployer.\n    address public immutable DEPLOYER;\n\n    /// @notice The peer sucker on the remote chain.\n    address public immutable override PEER;\n\n    /// @notice The ID of the project (on the local chain) that this sucker is associated with.\n    uint256 public immutable PROJECT_ID;\n\n    /// @notice A reasonable minimum gas limit for a basic cross-chain call. The minimum amount of gas required to call the `fromRemote` (succesfully/safely) on the remote chain.\n    uint32 constant MESSENGER_BASE_GAS_LIMIT = 300_000;\n\n    /// @notice A reasonable minimum gas limit used when bridging ERC-20s. The minimum amount of gas required to (succesfully/safely) perform a transfer on the remote chain.\n    uint32 constant MESSENGER_ERC20_MIN_GAS_LIMIT = 200_000;\n\n    //*********************************************************************//\n    // -------------------- internal stored properties ------------------- //\n    //*********************************************************************//\n\n    /// @notice Tracks whether individual leaves in a given token's merkle tree have been executed (to prevent double-spending).\n    /// @dev A leaf is \"executed\" when the tokens it represents are minted for its beneficiary.\n    mapping(address token => BitMaps.BitMap) executed;\n\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n    constructor(\n        IJBDirectory directory,\n        IJBTokens tokens,\n        IJBPermissions permissions,\n        address peer,\n        BPAddToBalanceMode atbMode,\n        uint256 projectId\n    ) JBPermissioned(permissions) {\n        DIRECTORY = directory;\n        TOKENS = tokens;\n        PEER = peer == address(0) ? address(this) : peer;\n        PROJECT_ID = projectId;\n        DEPLOYER = msg.sender;\n        ADD_TO_BALANCE_MODE = atbMode;\n\n        // Sanity check: make sure the merkle lib uses the same tree depth.\n        assert(MerkleLib.TREE_DEPTH == TREE_DEPTH);\n    }\n\n    //*********************************************************************//\n    // --------------------- external transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Prepare project tokens and the redemption amount backing them to be bridged to the remote chain.\n    /// @dev This adds the tokens and funds to the outbox tree for the `token`. They will be bridged by the next call to `toRemote` for the same `token`.\n    /// @param projectTokenAmount The amount of project tokens to prepare for bridging.\n    /// @param beneficiary The address of the recipient of the tokens on the remote chain.\n    /// @param minTokensReclaimed The minimum amount of terminal tokens to redeem for. If the amount reclaimed is less than this, the transaction will revert.\n    /// @param token The address of the terminal token to redeem for.\n    function prepare(uint256 projectTokenAmount, address beneficiary, uint256 minTokensReclaimed, address token)\n        external\n    {\n        // Make sure the beneficiary is not the zero address, as this would revert when minting on the remote chain.\n        if (beneficiary == address(0)) {\n            revert BENEFICIARY_NOT_ALLOWED();\n        }\n\n        // Get the project's token.\n        IERC20 projectToken = IERC20(address(TOKENS.tokenOf(PROJECT_ID)));\n        if (address(projectToken) == address(0)) {\n            revert ERC20_TOKEN_REQUIRED();\n        }\n\n        // Make sure that the token is mapped to a remote token.\n        if (remoteTokenFor[token].addr == address(0)) {\n            revert TOKEN_NOT_MAPPED(token);\n        }\n\n        // Transfer the tokens to this contract.\n        projectToken.safeTransferFrom(msg.sender, address(this), projectTokenAmount);\n\n        // Redeem the tokens.\n        uint256 terminalTokenAmount = _getBackingAssets(projectToken, projectTokenAmount, token, minTokensReclaimed);\n\n        // Insert the item into the outbox tree for the terminal `token`.\n        _insertIntoTree(projectTokenAmount, token, terminalTokenAmount, beneficiary);\n    }\n\n    /// @notice Bridge the project tokens, redeemed funds, and beneficiary information for a given `token` to the remote chain.\n    /// @dev This sends the outbox root for the specified `token` to the remote chain.\n    /// @param token The terminal token being bridged.\n    function toRemote(address token) external payable {\n        BPRemoteToken memory remoteToken = remoteTokenFor[token];\n\n        // Ensure that the amount being bridged exceeds the minimum bridge amount.\n        if (outbox[token].balance < remoteToken.minBridgeAmount) {\n            revert QUEUE_INSUFFECIENT_SIZE(remoteToken.minBridgeAmount, outbox[token].balance);\n        }\n\n        // Send the merkle root to the remote chain.\n        _sendRoot(msg.value, token, remoteToken);\n    }\n\n    /// @notice Receive a merkle root for a terminal token from the remote project.\n    /// @dev This can only be called by the messenger contract on the local chain, with a message from the remote peer.\n    /// @param root The merkle root, token, and amount being received.\n    function fromRemote(BPMessageRoot calldata root) external payable {\n        // Make sure that the message came from our peer.\n        if (!_isRemotePeer(msg.sender)) {\n            revert NOT_PEER();\n        }\n\n        // Increase the outstanding amount to be added to the project's balance by the amount being received.\n        amountToAddToBalance[root.token] += root.amount;\n\n        // If the received tree's nonce is greater than the current inbox tree's nonce, update the inbox tree.\n        // We can't revert because this could be a native token transfer. If we reverted, we would lose the native tokens.\n        if (root.remoteRoot.nonce > inbox[root.token].nonce) {\n            inbox[root.token] = root.remoteRoot;\n            emit NewInboxTreeRoot(root.token, root.remoteRoot.nonce, root.remoteRoot.root);\n        }\n    }\n\n    /// @notice BPClaim project tokens which have been bridged from the remote chain for their beneficiary.\n    /// @param claimData The terminal token, merkle tree leaf, and proof for the claim.\n    function claim(BPClaim calldata claimData) public {\n        // Attempt to validate the proof against the inbox tree for the terminal token.\n        _validate({\n            projectTokenAmount: claimData.leaf.projectTokenAmount,\n            terminalToken: claimData.token,\n            terminalTokenAmount: claimData.leaf.terminalTokenAmount,\n            beneficiary: claimData.leaf.beneficiary,\n            index: claimData.leaf.index,\n            leaves: claimData.proof\n        });\n\n        // If this contract's add to balance mode is `ON_CLAIM`, add the redeemed funds to the project's balance.\n        if (ADD_TO_BALANCE_MODE == BPAddToBalanceMode.ON_CLAIM) {\n            _addToBalance(claimData.token, claimData.leaf.terminalTokenAmount);\n        }\n\n        // Mint the project tokens for the beneficiary.\n        IJBController(address(DIRECTORY.controllerOf(PROJECT_ID))).mintTokensOf(\n            PROJECT_ID, claimData.leaf.projectTokenAmount, claimData.leaf.beneficiary, \"\", false\n        );\n\n        emit Claimed(\n            claimData.leaf.beneficiary,\n            claimData.token,\n            claimData.leaf.projectTokenAmount,\n            claimData.leaf.terminalTokenAmount,\n            claimData.leaf.index,\n            ADD_TO_BALANCE_MODE == BPAddToBalanceMode.ON_CLAIM ? true : false\n        );\n    }\n\n    /// @notice Performs multiple claims.\n    /// @param claims A list of claims to perform (including the terminal token, merkle tree leaf, and proof for each claim).\n    function claim(BPClaim[] calldata claims) external {\n        for (uint256 i = 0; i < claims.length; i++) {\n            claim(claims[i]);\n        }\n    }\n\n    /// @notice Adds the redeemed `token` balance to the projects terminal. Can only be used if `ADD_TO_BALANCE_MODE` is `MANUAL`.\n    /// @param token The address of the terminal token to add to the project's balance.\n    function addOutstandingAmountToBalance(address token) external {\n        if (ADD_TO_BALANCE_MODE != BPAddToBalanceMode.MANUAL) {\n            revert MANUAL_NOT_ALLOWED();\n        }\n\n        // Add entire outstanding amount to the project's balance.\n        _addToBalance(token, amountToAddToBalance[token]);\n    }\n\n    /// @notice Map an ERC-20 token on the local chain to an ERC-20 token on the remote chain, allowing that token to be bridged.\n    /// @param map The local and remote terminal token addresses to map, and minimum amount/gas limits for bridging them.\n    function mapToken(BPTokenMapping calldata map) public {\n        address token = map.localToken;\n        bool isNative = map.localToken == JBConstants.NATIVE_TOKEN;\n\n        // If the token being mapped is the native token, the `remoteToken` must also be the native token.\n        // The native token can also be mapped to the 0 address, which is used to disable native token bridging.\n        if (isNative && map.remoteToken != JBConstants.NATIVE_TOKEN && map.remoteToken != address(0)) {\n            revert INVALID_NATIVE_REMOTE_ADDRESS(map.remoteToken);\n        }\n\n        // Enforce a reasonable minimum gas limit for bridging. A minimum which is too low could lead to the loss of funds.\n        if (map.minGas < MESSENGER_ERC20_MIN_GAS_LIMIT && !isNative) {\n            revert BELOW_MIN_GAS(MESSENGER_ERC20_MIN_GAS_LIMIT, map.minGas);\n        }\n\n        // The caller must be the project owner or have the `QUEUE_RULESETS` permission from them.\n        _requirePermissionFrom(DIRECTORY.PROJECTS().ownerOf(PROJECT_ID), PROJECT_ID, JBPermissionIds.MAP_SUCKER_TOKEN);\n\n        // If the remote token is being set to the 0 address (which disables bridging), send any remaining outbox funds to the remote chain.\n        if (map.remoteToken == address(0) && outbox[token].balance != 0) _sendRoot(0, token, remoteTokenFor[token]);\n\n        // Update the token mapping.\n        remoteTokenFor[token] =\n            BPRemoteToken({minGas: map.minGas, addr: map.remoteToken, minBridgeAmount: map.minBridgeAmount});\n    }\n\n    /// @notice Map multiple ERC-20 tokens on the local chain to ERC-20 tokens on the remote chain, allowing those tokens to be bridged.\n    /// @param maps A list of local and remote terminal token addresses to map, and minimum amount/gas limits for bridging them.\n    function mapTokens(BPTokenMapping[] calldata maps) external {\n        for (uint256 i = 0; i < maps.length; i++) {\n            mapToken(maps[i]);\n        }\n    }\n\n    /// @notice Used to receive redeemed native tokens.\n    receive() external payable {}\n\n    //*********************************************************************//\n    // ------------------------ external views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Checks whether the specified token is mapped to a remote token.\n    /// @param token The terminal token to check.\n    /// @return A boolean which is `true` if the token is mapped to a remote token and `false` if it is not.\n    function isMapped(address token) external view override returns (bool) {\n        return remoteTokenFor[token].addr != address(0);\n    }\n\n    /// @notice Returns the chain on which the peer is located.\n    /// @return chain ID of the peer.\n    function peerChainID() external view virtual returns (uint256);\n\n    //*********************************************************************//\n    // --------------------- internal transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Inserts a new leaf into the outbox merkle tree for the specified `token`.\n    /// @param projectTokenAmount The amount of project tokens being redeemed.\n    /// @param token The terminal token being redeemed for.\n    /// @param terminalTokenAmount The amount of terminal tokens reclaimed by redeeming.\n    /// @param beneficiary The beneficiary of the project tokens on the remote chain.\n    function _insertIntoTree(\n        uint256 projectTokenAmount,\n        address token,\n        uint256 terminalTokenAmount,\n        address beneficiary\n    ) internal {\n        // Build a hash based on the token amounts and the beneficiary.\n        bytes32 hash = _buildTreeHash(projectTokenAmount, terminalTokenAmount, beneficiary);\n\n        // Create a new tree based on the outbox tree for the terminal token with the hash inserted.\n        MerkleLib.Tree memory tree = outbox[token].tree.insert(hash);\n\n        // Update the outbox tree and balance for the terminal token.\n        outbox[token].tree = tree;\n        outbox[token].balance += terminalTokenAmount;\n\n        emit InsertToOutboxTree(\n            beneficiary,\n            token,\n            hash,\n            tree.count - 1, // Subtract 1 since we want the 0-based index.\n            outbox[token].tree.root(),\n            projectTokenAmount,\n            terminalTokenAmount\n        );\n    }\n\n    /// @notice Send the outbox root for the specified token to the remote peer.\n    /// @dev The call may have a `transportPayment` for bridging native tokens. Require it to be `0` if it is not needed. Make sure if a value being paid to the bridge is expected to revert if the given value is `0`.\n    /// @param transportPayment the amount of `msg.value` that is going to get paid for sending this message. (usually derived from `msg.value`)\n    /// @param token The terminal token to bridge the merkle tree of.\n    /// @param remoteToken The remote token which the `token` is mapped to.\n    function _sendRoot(uint256 transportPayment, address token, BPRemoteToken memory remoteToken) internal virtual;\n\n    /// @notice Checks if the `sender` (`msg.sender`) is a valid representative of the remote peer.\n    /// @param sender The message's sender.\n    function _isRemotePeer(address sender) internal virtual returns (bool valid);\n\n    /// @notice Validates a leaf as being in the inbox merkle tree and registers the leaf as executed (to prevent double-spending).\n    /// @dev Reverts if the leaf is invalid.\n    /// @param projectTokenAmount The amount of project tokens which were redeemed.\n    /// @param terminalToken The terminal token that the project tokens were redeemed for.\n    /// @param terminalTokenAmount The amount of terminal tokens reclaimed by the redemption.\n    /// @param beneficiary The beneficiary which will receive the project tokens.\n    /// @param index The index of the leaf being proved in the terminal token's inbox tree.\n    /// @param leaves The leaves that prove that the leaf at the `index` is in the tree (i.e. the merkle branch that the leaf is on).\n    function _validate(\n        uint256 projectTokenAmount,\n        address terminalToken,\n        uint256 terminalTokenAmount,\n        address beneficiary,\n        uint256 index,\n        bytes32[TREE_DEPTH] calldata leaves\n    ) internal {\n        // Make sure the leaf has not already been executed.\n        if (executed[terminalToken].get(index)) {\n            revert LEAF_ALREADY_EXECUTED(index);\n        }\n\n        // Register the leaf as executed to prevent double-spending.\n        executed[terminalToken].set(index);\n\n        // Calculate the root based on the leaf, the branch, and the index.\n        bytes32 root = MerkleLib.branchRoot({\n            _item: _buildTreeHash(projectTokenAmount, terminalTokenAmount, beneficiary),\n            _branch: leaves,\n            _index: index\n        });\n\n        // Compare the calculated root to the terminal token's inbox root. Revert if they do not match.\n        if (root != inbox[terminalToken].root) {\n            revert INVALID_PROOF(inbox[terminalToken].root, root);\n        }\n    }\n\n    /// @notice Adds funds to the projects balance.\n    /// @param token The terminal token to add to the project's balance.\n    /// @param amount The amount of terminal tokens to add to the project's balance.\n    function _addToBalance(address token, uint256 amount) internal {\n        // Make sure that the current `amountToAddToBalance` is greater than or equal to the amount being added.\n        uint256 addableAmount = amountToAddToBalance[token];\n        if (amount > addableAmount) {\n            revert INSUFFICIENT_BALANCE();\n        }\n\n        // Update the outstanding amount of tokens which can be added to the project's balance.\n        unchecked {\n            amountToAddToBalance[token] = addableAmount - amount;\n        }\n\n        // Get the project's primary terminal for the token.\n        IJBTerminal terminal = DIRECTORY.primaryTerminalOf(PROJECT_ID, token);\n        if (address(terminal) == address(0)) revert NO_TERMINAL_FOR(PROJECT_ID, token);\n\n        // Perform the `addToBalance`.\n        if (token != JBConstants.NATIVE_TOKEN) {\n            uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n            SafeERC20.forceApprove(IERC20(token), address(terminal), amount);\n\n            terminal.addToBalanceOf(PROJECT_ID, token, amount, false, string(\"\"), bytes(\"\"));\n\n            // Sanity check: make sure we transfer the full amount.\n            assert(IERC20(token).balanceOf(address(this)) == balanceBefore - amount);\n        } else {\n            // If the token is the native token, use `msg.value`.\n            // slither-disable-next-line arbitrary-send-eth\n            terminal.addToBalanceOf{value: amount}(PROJECT_ID, token, amount, false, string(\"\"), bytes(\"\"));\n        }\n    }\n\n    /// @notice Redeems project tokens for terminal tokens.\n    /// @param amount The amount of project tokens to redeem.\n    /// @param token The terminal token to redeem for.\n    /// @param minReceivedTokens The minimum amount of terminal tokens to reclaim. If the amount reclaimed is less than this, the transaction will revert.\n    /// @return receivedAmount The amount of terminal tokens reclaimed by the redemption.\n    function _getBackingAssets(IERC20, uint256 amount, address token, uint256 minReceivedTokens)\n        internal\n        virtual\n        returns (uint256 receivedAmount)\n    {\n        // Get the project's primary terminal for `token`. We will redeem from this terminal.\n        IJBRedeemTerminal terminal = IJBRedeemTerminal(address(DIRECTORY.primaryTerminalOf(PROJECT_ID, token)));\n\n        // If the project doesn't have a primary terminal for `token`, revert.\n        if (address(terminal) == address(0)) {\n            revert NO_TERMINAL_FOR(PROJECT_ID, token);\n        }\n\n        // Redeem the tokens.\n        uint256 balanceBefore = _balanceOf(token, address(this));\n        receivedAmount = terminal.redeemTokensOf(\n            address(this), PROJECT_ID, token, amount, minReceivedTokens, payable(address(this)), bytes(\"\")\n        );\n\n        // Sanity check to make sure we received the expected amount.\n        // This prevents malicious terminals from reporting amounts other than what they send.\n        assert(receivedAmount == _balanceOf(token, address(this)) - balanceBefore);\n    }\n\n    /// @notice Builds a hash as they are stored in the merkle tree.\n    /// @param projectTokenAmount The amount of project tokens being redeemed.\n    /// @param terminalTokenAmount The amount of terminal tokens being reclaimed by the redemption.\n    /// @param beneficiary The beneficiary which will receive the project tokens.\n    function _buildTreeHash(uint256 projectTokenAmount, uint256 terminalTokenAmount, address beneficiary)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(projectTokenAmount, terminalTokenAmount, beneficiary));\n    }\n\n    /// @notice Helper to get the `addr`'s balance for a given `token`.\n    /// @param token The token to get the balance for.\n    /// @param addr The address to get the `token` balance of.\n    /// @return balance The address' `token` balance.\n    function _balanceOf(address token, address addr) internal view returns (uint256 balance) {\n        if (token == JBConstants.NATIVE_TOKEN) {\n            return addr.balance;\n        }\n\n        return IERC20(token).balanceOf(addr);\n    }\n}\n"
			},
			"src/deployers/BPOptimismSuckerDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBPermissioned} from \"@bananapus/core/src/abstract/JBPermissioned.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBRulesets} from \"@bananapus/core/src/interfaces/IJBRulesets.sol\";\nimport {IJBTokens} from \"@bananapus/core/src/interfaces/IJBTokens.sol\";\nimport {OPStandardBridge} from \"../interfaces/OPStandardBridge.sol\";\nimport {OPMessenger} from \"../interfaces/OPMessenger.sol\";\nimport {BPOptimismSucker} from \"../BPOptimismSucker.sol\";\nimport {BPAddToBalanceMode} from \"../enums/BPAddToBalanceMode.sol\";\nimport {IBPSucker} from \"./../interfaces/IBPSucker.sol\";\nimport {IBPSuckerDeployer} from \"./../interfaces/IBPSuckerDeployer.sol\";\n\n/// @notice An `IBPSuckerDeployerFeeless` implementation to deploy `BPOptimismSucker` contracts.\ncontract BPOptimismSuckerDeployer is JBPermissioned, IBPSuckerDeployer {\n    error ONLY_SUCKERS();\n    error ALREADY_CONFIGURED();\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory immutable DIRECTORY;\n\n    /// @notice The contract that manages token minting and burning.\n    IJBTokens immutable TOKENS;\n\n    /// @notice Only this address can configure this deployer, can only be used once.\n    address immutable LAYER_SPECIFIC_CONFIGURATOR;\n\n    /// @notice The messenger used to send messages between the local and remote sucker.\n    OPMessenger public MESSENGER;\n\n    /// @notice The bridge used to bridge tokens between the local and remote chain.\n    OPStandardBridge public BRIDGE;\n\n    /// @notice A mapping of suckers deployed by this contract.\n    mapping(address => bool) public isSucker;\n\n    /// @notice A temporary storage slot used by suckers to maintain deterministic deploys.\n    uint256 public TEMP_ID_STORE;\n\n    constructor(IJBDirectory directory, IJBTokens tokens, IJBPermissions permissions, address _configurator)\n        JBPermissioned(permissions)\n    {\n        LAYER_SPECIFIC_CONFIGURATOR = _configurator;\n        DIRECTORY = directory;\n        TOKENS = tokens;\n    }\n\n    /// @notice Create a new `BPSucker` for a specific project.\n    /// @dev Uses the sender address as the salt, which means the same sender must call this function on both chains.\n    /// @param localProjectId The project's ID on the local chain.\n    /// @param salt The salt to use for the `create2` address.\n    /// @return sucker The address of the new sucker.\n    function createForSender(uint256 localProjectId, bytes32 salt) external returns (IBPSucker sucker) {\n        salt = keccak256(abi.encodePacked(msg.sender, salt));\n\n        // Set for a callback to this contract.\n        TEMP_ID_STORE = localProjectId;\n\n        sucker = IBPSucker(\n            address(\n                new BPOptimismSucker{salt: salt}(DIRECTORY, TOKENS, PERMISSIONS, address(0), BPAddToBalanceMode.MANUAL)\n            )\n        );\n\n        // TODO: See if resetting this value is cheaper than deletion\n        // Delete after callback should complete.\n        /* delete TEMP_ID_STORE; */\n\n        isSucker[address(sucker)] = true;\n    }\n\n    /// @notice handles some layer specific configuration that can't be done in the constructor otherwise deployment addresses would change.\n    /// @notice messenger the OPMesssenger on this layer.\n    /// @notice bridge the OPStandardBridge on this layer.\n    function configureLayerSpecific(OPMessenger messenger, OPStandardBridge bridge) external {\n        if (address(MESSENGER) != address(0) || address(BRIDGE) != address(0)) {\n            revert ALREADY_CONFIGURED();\n        }\n        // Configure these layer specific properties.\n        // This is done in a seperate call to make the deployment code chain agnostic.\n        MESSENGER = messenger;\n        BRIDGE = bridge;\n    }\n}\n"
			},
			"src/enums/BPAddToBalanceMode.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Options for how a `BPSucker`'s `amountToAddToBalance` gets added to its project's balance.\n/// @custom:element MANUAL The amount gets added to the project's balance manually by calling `addOutstandingAmountToBalance`.\n/// @custom:element ON_CLAIM The amount gets added to the project's balance automatically when `claim` is called.\nenum BPAddToBalanceMode {\n    MANUAL,\n    ON_CLAIM\n}\n"
			},
			"src/interfaces/IBPSucker.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BPTokenMapping} from \"../structs/BPTokenMapping.sol\";\n\ninterface IBPSucker {\n    function PEER() external view returns (address);\n\n    function peerChainID() external view returns (uint256 chainId);\n\n    function isMapped(address token) external view returns (bool);\n\n    function prepare(uint256 projectTokenAmount, address beneficiary, uint256 minTokensReclaimed, address token)\n        external;\n\n    function mapToken(BPTokenMapping calldata map) external;\n\n    function mapTokens(BPTokenMapping[] calldata maps) external;\n\n    event NewInboxTreeRoot(address indexed token, uint64 nonce, bytes32 root);\n\n    event RootToRemote(bytes32 indexed root, address indexed terminalToken, uint256 index, uint64 nonce);\n\n    event Claimed(\n        address beneficiary,\n        address token,\n        uint256 projectTokenAmount,\n        uint256 terminalTokenAmount,\n        uint256 index,\n        bool autoAddedToBalance\n    );\n\n    event InsertToOutboxTree(\n        address indexed beneficiary,\n        address indexed terminalToken,\n        bytes32 hashed,\n        uint256 index,\n        bytes32 root,\n        uint256 projectTokenAmount,\n        uint256 terminalTokenAmount\n    );\n}\n"
			},
			"src/interfaces/IBPSuckerDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBPSucker} from \"./IBPSucker.sol\";\n\ninterface IBPSuckerDeployer {\n    function createForSender(uint256 localProjectId, bytes32 salt) external returns (IBPSucker sucker);\n\n    function TEMP_ID_STORE() external view returns (uint256);\n}\n"
			},
			"src/interfaces/OPMessenger.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OPMessenger {\n    function xDomainMessageSender() external returns (address);\n\n    function sendMessage(address _target, bytes memory _message, uint32 _gasLimit) external payable;\n\n    function bridgeERC20To(\n        address localToken,\n        address remoteToken,\n        address to,\n        uint256 amount,\n        uint32 minGasLimit,\n        bytes calldata extraData\n    ) external;\n}\n"
			},
			"src/interfaces/OPStandardBridge.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OPStandardBridge {\n    /**\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the\n     *         ERC20 token on the other chain does not recognize the local token as the correct\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n     *         this chain.\n     *\n     * @param localToken  Address of the ERC20 on this chain.\n     * @param remoteToken Address of the corresponding token on the remote chain.\n     * @param to          Address of the receiver.\n     * @param amount      Amount of local tokens to deposit.\n     * @param minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeERC20To(\n        address localToken,\n        address remoteToken,\n        address to,\n        uint256 amount,\n        uint32 minGasLimit,\n        bytes calldata extraData\n    ) external;\n}\n"
			},
			"src/structs/BPClaim.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BPLeaf} from \"./BPLeaf.sol\";\n\nstruct BPClaim {\n    address token;\n    BPLeaf leaf;\n    // Must be `BPSucker.TREE_DEPTH` long.\n    bytes32[32] proof;\n}\n"
			},
			"src/structs/BPInboxTreeRoot.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice The root of an inbox tree for a given token in a `BPSucker`.\n/// @dev Inbox trees are used to receive from the remote chain to the local chain. Tokens can be `claim`ed from the inbox tree.\n/// @custom:member nonce Tracks the nonce of the tree. The nonce cannot decrease.\n/// @custom:member root The root of the tree.\nstruct BPInboxTreeRoot {\n    uint64 nonce;\n    bytes32 root;\n}\n"
			},
			"src/structs/BPLeaf.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A leaf in the inbox or outbox tree of a `BPSucker`. Used to `claim` tokens from the inbox tree.\nstruct BPLeaf {\n    uint256 index;\n    address beneficiary;\n    uint256 projectTokenAmount;\n    uint256 terminalTokenAmount;\n}\n"
			},
			"src/structs/BPMessageRoot.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BPInboxTreeRoot} from \"./BPInboxTreeRoot.sol\";\n\n/// @notice Information about the remote (inbox) tree's root, passed in a message from the remote chain.\n/// @custom:member The address of the terminal token that the tree tracks.\n/// @custom:member The amount of tokens being sent.\n/// @custom:member The root of the merkle tree.\nstruct BPMessageRoot {\n    address token;\n    uint256 amount;\n    BPInboxTreeRoot remoteRoot;\n}\n"
			},
			"src/structs/BPOutboxTree.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {MerkleLib} from \"../utils/MerkleLib.sol\";\n\n/// @notice A merkle tree used to track the outbox for a given token in a `BPSucker`.\n/// @dev The outbox is used to send from the local chain to the remote chain.\nstruct BPOutboxTree {\n    uint64 nonce;\n    uint256 balance;\n    MerkleLib.Tree tree;\n}\n"
			},
			"src/structs/BPRemoteToken.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A struct that represents a token on the remote chain.\n/// @custom:member minGas The minimum gas to use when bridging.\n/// @custom:member addr The address of the token on the remote chain.\n/// @custom:member minBridgeAmount The minimum amount to bridge.\nstruct BPRemoteToken {\n    uint32 minGas;\n    address addr;\n    uint256 minBridgeAmount;\n}\n"
			},
			"src/structs/BPTokenMapping.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct BPTokenMapping {\n    address localToken;\n    uint32 minGas;\n    address remoteToken;\n    uint256 minBridgeAmount;\n}\n"
			},
			"src/utils/MerkleLib.sol": {
				"content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.23;\n\n/**\n * @title MerkleLib\n * @author Illusory Systems Inc.\n * @notice An incremental merkle tree modeled on the eth2 deposit contract.\n *\n */\nlibrary MerkleLib {\n    // ========== Custom Errors ===========\n\n    error MerkleLib__insert_treeIsFull();\n\n    // ============ Constants =============\n\n    uint256 internal constant TREE_DEPTH = 32;\n    uint256 internal constant MAX_LEAVES = 2 ** TREE_DEPTH - 1;\n\n    /**\n     * @dev Z_i represent the hash values at different heights for a binary tree with leaf values equal to `0`.\n     * (e.g. Z_1 is the keccak256 hash of (0x0, 0x0), Z_2 is the keccak256 hash of (Z_1, Z_1), etc...)\n     * Z_0 is the bottom of the 33-layer tree, Z_32 is the top (i.e. root).\n     * Used to shortcut calculation in root calculation methods below.\n     */\n    bytes32 internal constant Z_0 = hex\"0000000000000000000000000000000000000000000000000000000000000000\";\n    bytes32 internal constant Z_1 = hex\"ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5\";\n    bytes32 internal constant Z_2 = hex\"b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30\";\n    bytes32 internal constant Z_3 = hex\"21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85\";\n    bytes32 internal constant Z_4 = hex\"e58769b32a1beaf1ea27375a44095a0d1fb664ce2dd358e7fcbfb78c26a19344\";\n    bytes32 internal constant Z_5 = hex\"0eb01ebfc9ed27500cd4dfc979272d1f0913cc9f66540d7e8005811109e1cf2d\";\n    bytes32 internal constant Z_6 = hex\"887c22bd8750d34016ac3c66b5ff102dacdd73f6b014e710b51e8022af9a1968\";\n    bytes32 internal constant Z_7 = hex\"ffd70157e48063fc33c97a050f7f640233bf646cc98d9524c6b92bcf3ab56f83\";\n    bytes32 internal constant Z_8 = hex\"9867cc5f7f196b93bae1e27e6320742445d290f2263827498b54fec539f756af\";\n    bytes32 internal constant Z_9 = hex\"cefad4e508c098b9a7e1d8feb19955fb02ba9675585078710969d3440f5054e0\";\n    bytes32 internal constant Z_10 = hex\"f9dc3e7fe016e050eff260334f18a5d4fe391d82092319f5964f2e2eb7c1c3a5\";\n    bytes32 internal constant Z_11 = hex\"f8b13a49e282f609c317a833fb8d976d11517c571d1221a265d25af778ecf892\";\n    bytes32 internal constant Z_12 = hex\"3490c6ceeb450aecdc82e28293031d10c7d73bf85e57bf041a97360aa2c5d99c\";\n    bytes32 internal constant Z_13 = hex\"c1df82d9c4b87413eae2ef048f94b4d3554cea73d92b0f7af96e0271c691e2bb\";\n    bytes32 internal constant Z_14 = hex\"5c67add7c6caf302256adedf7ab114da0acfe870d449a3a489f781d659e8becc\";\n    bytes32 internal constant Z_15 = hex\"da7bce9f4e8618b6bd2f4132ce798cdc7a60e7e1460a7299e3c6342a579626d2\";\n    bytes32 internal constant Z_16 = hex\"2733e50f526ec2fa19a22b31e8ed50f23cd1fdf94c9154ed3a7609a2f1ff981f\";\n    bytes32 internal constant Z_17 = hex\"e1d3b5c807b281e4683cc6d6315cf95b9ade8641defcb32372f1c126e398ef7a\";\n    bytes32 internal constant Z_18 = hex\"5a2dce0a8a7f68bb74560f8f71837c2c2ebbcbf7fffb42ae1896f13f7c7479a0\";\n    bytes32 internal constant Z_19 = hex\"b46a28b6f55540f89444f63de0378e3d121be09e06cc9ded1c20e65876d36aa0\";\n    bytes32 internal constant Z_20 = hex\"c65e9645644786b620e2dd2ad648ddfcbf4a7e5b1a3a4ecfe7f64667a3f0b7e2\";\n    bytes32 internal constant Z_21 = hex\"f4418588ed35a2458cffeb39b93d26f18d2ab13bdce6aee58e7b99359ec2dfd9\";\n    bytes32 internal constant Z_22 = hex\"5a9c16dc00d6ef18b7933a6f8dc65ccb55667138776f7dea101070dc8796e377\";\n    bytes32 internal constant Z_23 = hex\"4df84f40ae0c8229d0d6069e5c8f39a7c299677a09d367fc7b05e3bc380ee652\";\n    bytes32 internal constant Z_24 = hex\"cdc72595f74c7b1043d0e1ffbab734648c838dfb0527d971b602bc216c9619ef\";\n    bytes32 internal constant Z_25 = hex\"0abf5ac974a1ed57f4050aa510dd9c74f508277b39d7973bb2dfccc5eeb0618d\";\n    bytes32 internal constant Z_26 = hex\"b8cd74046ff337f0a7bf2c8e03e10f642c1886798d71806ab1e888d9e5ee87d0\";\n    bytes32 internal constant Z_27 = hex\"838c5655cb21c6cb83313b5a631175dff4963772cce9108188b34ac87c81c41e\";\n    bytes32 internal constant Z_28 = hex\"662ee4dd2dd7b2bc707961b1e646c4047669dcb6584f0d8d770daf5d7e7deb2e\";\n    bytes32 internal constant Z_29 = hex\"388ab20e2573d171a88108e79d820e98f26c0b84aa8b2f4aa4968dbb818ea322\";\n    bytes32 internal constant Z_30 = hex\"93237c50ba75ee485f4c22adf2f741400bdf8d6a9cc7df7ecae576221665d735\";\n    bytes32 internal constant Z_31 = hex\"8448818bb4ae4562849e949e17ac16e0be16688e156b5cf15e098c627c0056a9\";\n    bytes32 internal constant Z_32 = hex\"27ae5ba08d7291c96c8cbddcc148bf48a6d68c7974b94356f53754ef6171d757\";\n\n    // ============= Structs ==============\n\n    /**\n     * @notice Struct representing incremental merkle tree. Contains current\n     * branch and the number of inserted leaves in the tree.\n     *\n     */\n    struct Tree {\n        bytes32[TREE_DEPTH] branch;\n        uint256 count;\n    }\n\n    // ========= Write Methods =========\n\n    /**\n     * @notice Inserts a given node (leaf) into merkle tree. Operates on an in-memory tree and\n     * returns an updated version of that tree.\n     * @dev Reverts if the tree is already full.\n     * @param node Element to insert into tree.\n     * @return Tree Updated tree.\n     *\n     */\n    function insert(Tree memory tree, bytes32 node) internal pure returns (Tree memory) {\n        // Update tree.count to increase the current count by 1 since we'll be including a new node.\n        uint256 size = ++tree.count;\n        if (size > MAX_LEAVES) revert MerkleLib__insert_treeIsFull();\n\n        // Loop starting at 0, ending when we've finished inserting the node (i.e. hashing it) into\n        // the active branch. Each loop we cut size in half, hashing the inserted node up the active\n        // branch along the way.\n        for (uint256 i; i < TREE_DEPTH;) {\n            // Check if the current size is odd; if so, we set this index in the branch to be the node.\n            if ((size & 1) == 1) {\n                // If i > 0, then this node will be a hash of the original node with every layer up\n                // until layer `i`.\n                tree.branch[i] = node;\n                return tree;\n            }\n            // If the size is not yet odd, we hash the current index in the tree branch with the node.\n            node = keccak256(abi.encodePacked(tree.branch[i], node));\n            size >>= 1; // Cut size in half (statement equivalent to: `size /= 2`).\n\n            unchecked {\n                ++i;\n            }\n        }\n        // As the loop should always end prematurely with the `return` statement, this code should\n        // be unreachable. We revert here just to be safe.\n        revert MerkleLib__insert_treeIsFull();\n    }\n\n    // ========= Read Methods =========\n\n    /**\n     * @notice Calculates and returns tree's current root.\n     * @return _current bytes32 root.\n     *\n     */\n    function root(Tree storage tree) internal view returns (bytes32 _current) {\n        uint256 _index = tree.count;\n\n        if (_index == 0) {\n            return Z_32;\n        }\n\n        uint256 i;\n        assembly {\n            let TREE_SLOT := tree.slot\n\n            for {} true {} {\n                for {} true {} {\n                    if and(_index, 1) {\n                        mstore(0, sload(TREE_SLOT))\n                        mstore(0x20, Z_0)\n                        _current := keccak256(0, 0x40)\n                        break\n                    }\n\n                    if and(_index, shl(1, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 1)))\n                        mstore(0x20, Z_1)\n                        _current := keccak256(0, 0x40)\n                        i := 1\n                        break\n                    }\n\n                    if and(_index, shl(2, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 2)))\n                        mstore(0x20, Z_2)\n                        _current := keccak256(0, 0x40)\n                        i := 2\n                        break\n                    }\n\n                    if and(_index, shl(3, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 3)))\n                        mstore(0x20, Z_3)\n                        _current := keccak256(0, 0x40)\n                        i := 3\n                        break\n                    }\n\n                    if and(_index, shl(4, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 4)))\n                        mstore(0x20, Z_4)\n                        _current := keccak256(0, 0x40)\n                        i := 4\n                        break\n                    }\n\n                    if and(_index, shl(5, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 5)))\n                        mstore(0x20, Z_5)\n                        _current := keccak256(0, 0x40)\n                        i := 5\n                        break\n                    }\n\n                    if and(_index, shl(6, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 6)))\n                        mstore(0x20, Z_6)\n                        _current := keccak256(0, 0x40)\n                        i := 6\n                        break\n                    }\n\n                    if and(_index, shl(7, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 7)))\n                        mstore(0x20, Z_7)\n                        _current := keccak256(0, 0x40)\n                        i := 7\n                        break\n                    }\n\n                    if and(_index, shl(8, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 8)))\n                        mstore(0x20, Z_8)\n                        _current := keccak256(0, 0x40)\n                        i := 8\n                        break\n                    }\n\n                    if and(_index, shl(9, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 9)))\n                        mstore(0x20, Z_9)\n                        _current := keccak256(0, 0x40)\n                        i := 9\n                        break\n                    }\n\n                    if and(_index, shl(10, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 10)))\n                        mstore(0x20, Z_10)\n                        _current := keccak256(0, 0x40)\n                        i := 10\n                        break\n                    }\n\n                    if and(_index, shl(11, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 11)))\n                        mstore(0x20, Z_11)\n                        _current := keccak256(0, 0x40)\n                        i := 11\n                        break\n                    }\n\n                    if and(_index, shl(12, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 12)))\n                        mstore(0x20, Z_12)\n                        _current := keccak256(0, 0x40)\n                        i := 12\n                        break\n                    }\n\n                    if and(_index, shl(13, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 13)))\n                        mstore(0x20, Z_13)\n                        _current := keccak256(0, 0x40)\n                        i := 13\n                        break\n                    }\n\n                    if and(_index, shl(14, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 14)))\n                        mstore(0x20, Z_14)\n                        _current := keccak256(0, 0x40)\n                        i := 14\n                        break\n                    }\n\n                    if and(_index, shl(15, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 15)))\n                        mstore(0x20, Z_15)\n                        _current := keccak256(0, 0x40)\n                        i := 15\n                        break\n                    }\n\n                    if and(_index, shl(16, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 16)))\n                        mstore(0x20, Z_16)\n                        _current := keccak256(0, 0x40)\n                        i := 16\n                        break\n                    }\n\n                    if and(_index, shl(17, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 17)))\n                        mstore(0x20, Z_17)\n                        _current := keccak256(0, 0x40)\n                        i := 17\n                        break\n                    }\n\n                    if and(_index, shl(18, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 18)))\n                        mstore(0x20, Z_18)\n                        _current := keccak256(0, 0x40)\n                        i := 18\n                        break\n                    }\n\n                    if and(_index, shl(19, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 19)))\n                        mstore(0x20, Z_19)\n                        _current := keccak256(0, 0x40)\n                        i := 19\n                        break\n                    }\n\n                    if and(_index, shl(20, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 20)))\n                        mstore(0x20, Z_20)\n                        _current := keccak256(0, 0x40)\n                        i := 20\n                        break\n                    }\n\n                    if and(_index, shl(21, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 21)))\n                        mstore(0x20, Z_21)\n                        _current := keccak256(0, 0x40)\n                        i := 21\n                        break\n                    }\n\n                    if and(_index, shl(22, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 22)))\n                        mstore(0x20, Z_22)\n                        _current := keccak256(0, 0x40)\n                        i := 22\n                        break\n                    }\n\n                    if and(_index, shl(23, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 23)))\n                        mstore(0x20, Z_23)\n                        _current := keccak256(0, 0x40)\n                        i := 23\n                        break\n                    }\n\n                    if and(_index, shl(24, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 24)))\n                        mstore(0x20, Z_24)\n                        _current := keccak256(0, 0x40)\n                        i := 24\n                        break\n                    }\n\n                    if and(_index, shl(25, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 25)))\n                        mstore(0x20, Z_25)\n                        _current := keccak256(0, 0x40)\n                        i := 25\n                        break\n                    }\n\n                    if and(_index, shl(26, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 26)))\n                        mstore(0x20, Z_26)\n                        _current := keccak256(0, 0x40)\n                        i := 26\n                        break\n                    }\n\n                    if and(_index, shl(27, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 27)))\n                        mstore(0x20, Z_27)\n                        _current := keccak256(0, 0x40)\n                        i := 27\n                        break\n                    }\n\n                    if and(_index, shl(28, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 28)))\n                        mstore(0x20, Z_28)\n                        _current := keccak256(0, 0x40)\n                        i := 28\n                        break\n                    }\n\n                    if and(_index, shl(29, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 29)))\n                        mstore(0x20, Z_29)\n                        _current := keccak256(0, 0x40)\n                        i := 29\n                        break\n                    }\n\n                    if and(_index, shl(30, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 30)))\n                        mstore(0x20, Z_30)\n                        _current := keccak256(0, 0x40)\n                        i := 30\n                        break\n                    }\n\n                    if and(_index, shl(31, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 31)))\n                        mstore(0x20, Z_31)\n                        _current := keccak256(0, 0x40)\n                        i := 31\n                        break\n                    }\n\n                    _current := Z_32\n                    i := 32\n                    break\n                }\n\n                if gt(i, 30) { break }\n\n                {\n                    if lt(i, 1) {\n                        switch and(_index, shl(1, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_1)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 1)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 2) {\n                        switch and(_index, shl(2, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_2)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 2)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 3) {\n                        switch and(_index, shl(3, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_3)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 3)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 4) {\n                        switch and(_index, shl(4, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_4)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 4)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 5) {\n                        switch and(_index, shl(5, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_5)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 5)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 6) {\n                        switch and(_index, shl(6, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_6)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 6)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 7) {\n                        switch and(_index, shl(7, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_7)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 7)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 8) {\n                        switch and(_index, shl(8, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_8)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 8)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 9) {\n                        switch and(_index, shl(9, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_9)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 9)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 10) {\n                        switch and(_index, shl(10, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_10)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 10)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 11) {\n                        switch and(_index, shl(11, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_11)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 11)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 12) {\n                        switch and(_index, shl(12, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_12)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 12)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 13) {\n                        switch and(_index, shl(13, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_13)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 13)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 14) {\n                        switch and(_index, shl(14, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_14)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 14)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 15) {\n                        switch and(_index, shl(15, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_15)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 15)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 16) {\n                        switch and(_index, shl(16, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_16)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 16)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 17) {\n                        switch and(_index, shl(17, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_17)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 17)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 18) {\n                        switch and(_index, shl(18, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_18)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 18)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 19) {\n                        switch and(_index, shl(19, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_19)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 19)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 20) {\n                        switch and(_index, shl(20, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_20)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 20)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 21) {\n                        switch and(_index, shl(21, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_21)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 21)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 22) {\n                        switch and(_index, shl(22, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_22)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 22)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 23) {\n                        switch and(_index, shl(23, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_23)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 23)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 24) {\n                        switch and(_index, shl(24, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_24)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 24)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 25) {\n                        switch and(_index, shl(25, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_25)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 25)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 26) {\n                        switch and(_index, shl(26, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_26)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 26)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 27) {\n                        switch and(_index, shl(27, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_27)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 27)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 28) {\n                        switch and(_index, shl(28, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_28)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 28)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 29) {\n                        switch and(_index, shl(29, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_29)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 29)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 30) {\n                        switch and(_index, shl(30, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_30)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 30)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 31) {\n                        switch and(_index, shl(31, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_31)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 31)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n                }\n\n                break\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates and returns the merkle root for the given leaf `_item`,\n     * a merkle branch, and the index of `_item` in the tree.\n     * @param _item Merkle leaf\n     * @param _branch Merkle proof\n     * @param _index Index of `_item` in tree\n     * @return _current Calculated merkle root\n     *\n     */\n    function branchRoot(bytes32 _item, bytes32[TREE_DEPTH] memory _branch, uint256 _index)\n        internal\n        pure\n        returns (bytes32 _current)\n    {\n        assembly {\n            _current := _item\n            let BRANCH_DATA_OFFSET := _branch\n            let f\n\n            f := shl(5, and(_index, 1))\n            mstore(f, _current)\n            mstore(sub(0x20, f), mload(BRANCH_DATA_OFFSET))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(1, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 1))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(2, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 2))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(3, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 3))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(4, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 4))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(5, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 5))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(6, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 6))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(7, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 7))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(8, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 8))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(9, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 9))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(10, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 10))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(11, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 11))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(12, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 12))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(13, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 13))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(14, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 14))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(15, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 15))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(16, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 16))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(17, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 17))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(18, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 18))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(19, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 19))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(20, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 20))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(21, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 21))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(22, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 22))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(23, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 23))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(24, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 24))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(25, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 25))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(26, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 26))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(27, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 27))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(28, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 28))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(29, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 29))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(30, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 30))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(31, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 31))))\n            _current := keccak256(0, 0x40)\n        }\n    }\n}\n"
			},
			"src/BPBaseSucker.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport \"./BPOptimismSucker.sol\";\n\ncontract BPBaseSucker is BPOptimismSucker {\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n\n    constructor(\n        IJBDirectory directory,\n        IJBTokens tokens,\n        IJBPermissions permissions,\n        address peer,\n        BPAddToBalanceMode atbMode\n    ) BPOptimismSucker(directory, tokens, permissions, peer, atbMode) {}\n\n    //*********************************************************************//\n    // ------------------------ external views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Returns the chain on which the peer is located.\n    /// @return chainId of the peer.\n    function peerChainID() external view virtual override returns (uint256 chainId) {\n        uint256 _localChainId = block.chainid;\n        if (_localChainId == 1) return 8453;\n        if (_localChainId == 8453) return 1;\n        if (_localChainId == 11155111) return 84532;\n        if (_localChainId == 84532) return 11155111;\n    }\n}\n"
			},
			"src/deployers/BPBaseSuckerDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBPermissioned} from \"@bananapus/core/src/abstract/JBPermissioned.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBRulesets} from \"@bananapus/core/src/interfaces/IJBRulesets.sol\";\nimport {IJBTokens} from \"@bananapus/core/src/interfaces/IJBTokens.sol\";\nimport {OPStandardBridge} from \"../interfaces/OPStandardBridge.sol\";\nimport {OPMessenger} from \"../interfaces/OPMessenger.sol\";\nimport {BPBaseSucker} from \"../BPBaseSucker.sol\";\nimport {BPAddToBalanceMode} from \"../enums/BPAddToBalanceMode.sol\";\nimport {IBPSucker} from \"./../interfaces/IBPSucker.sol\";\nimport {IBPSuckerDeployer} from \"./../interfaces/IBPSuckerDeployer.sol\";\n\ncontract BPBaseSuckerDeployer is JBPermissioned, IBPSuckerDeployer {\n    error ONLY_SUCKERS();\n    error ALREADY_CONFIGURED();\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory immutable DIRECTORY;\n\n    /// @notice The contract that manages token minting and burning.\n    IJBTokens immutable TOKENS;\n\n    /// @notice Only this address can configure this deployer, can only be used once.\n    address immutable LAYER_SPECIFIC_CONFIGURATOR;\n\n    /// @notice The messenger used to send messages between the local and remote sucker.\n    OPMessenger public MESSENGER;\n\n    /// @notice The bridge used to bridge tokens between the local and remote chain.\n    OPStandardBridge public BRIDGE;\n\n    /// @notice A mapping of suckers deployed by this contract.\n    mapping(address => bool) public isSucker;\n\n    /// @notice A temporary storage slot used by suckers to maintain deterministic deploys.\n    uint256 public TEMP_ID_STORE;\n\n    constructor(IJBDirectory directory, IJBTokens tokens, IJBPermissions permissions, address _configurator)\n        JBPermissioned(permissions)\n    {\n        LAYER_SPECIFIC_CONFIGURATOR = _configurator;\n        DIRECTORY = directory;\n        TOKENS = tokens;\n    }\n\n    /// @notice Create a new `BPSucker` for a specific project.\n    /// @dev Uses the sender address as the salt, which means the same sender must call this function on both chains.\n    /// @param localProjectId The project's ID on the local chain.\n    /// @param salt The salt to use for the `create2` address.\n    /// @return sucker The address of the new sucker.\n    function createForSender(uint256 localProjectId, bytes32 salt) external returns (IBPSucker sucker) {\n        salt = keccak256(abi.encodePacked(msg.sender, salt));\n\n        // Set for a callback to this contract.\n        TEMP_ID_STORE = localProjectId;\n\n        sucker = IBPSucker(\n            address(new BPBaseSucker{salt: salt}(DIRECTORY, TOKENS, PERMISSIONS, address(0), BPAddToBalanceMode.MANUAL))\n        );\n\n        // TODO: See if resetting this value is cheaper than deletion\n        // Delete after callback should complete.\n        /* delete TEMP_ID_STORE; */\n\n        isSucker[address(sucker)] = true;\n    }\n\n    /// @notice handles some layer specific configuration that can't be done in the constructor otherwise deployment addresses would change.\n    /// @notice messenger the OPMesssenger on this layer.\n    /// @notice bridge the OPStandardBridge on this layer.\n    function configureLayerSpecific(OPMessenger messenger, OPStandardBridge bridge) external {\n        if (address(MESSENGER) != address(0) || address(BRIDGE) != address(0)) {\n            revert ALREADY_CONFIGURED();\n        }\n        // Configure these layer specific properties.\n        // This is done in a seperate call to make the deployment code chain agnostic.\n        MESSENGER = messenger;\n        BRIDGE = bridge;\n    }\n}\n"
			},
			"node_modules/@arbitrum/nitro-contracts/src/bridge/IBridge.sol": {
				"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\nimport \"./IOwnable.sol\";\n\ninterface IBridge {\n    /// @dev This is an instruction to offchain readers to inform them where to look\n    ///      for sequencer inbox batch data. This is not the type of data (eg. das, brotli encoded, or blob versioned hash)\n    ///      and this enum is not used in the state transition function, rather it informs an offchain\n    ///      reader where to find the data so that they can supply it to the replay binary\n    enum BatchDataLocation {\n        /// @notice The data can be found in the transaction call data\n        TxInput,\n        /// @notice The data can be found in an event emitted during the transaction\n        SeparateBatchEvent,\n        /// @notice This batch contains no data\n        NoData,\n        /// @notice The data can be found in the 4844 data blobs on this transaction\n        Blob\n    }\n\n    struct TimeBounds {\n        uint64 minTimestamp;\n        uint64 maxTimestamp;\n        uint64 minBlockNumber;\n        uint64 maxBlockNumber;\n    }\n\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash,\n        uint256 baseFeeL1,\n        uint64 timestamp\n    );\n\n    event BridgeCallTriggered(\n        address indexed outbox,\n        address indexed to,\n        uint256 value,\n        bytes data\n    );\n\n    event InboxToggle(address indexed inbox, bool enabled);\n\n    event OutboxToggle(address indexed outbox, bool enabled);\n\n    event SequencerInboxUpdated(address newSequencerInbox);\n\n    event RollupUpdated(address rollup);\n\n    function allowedDelayedInboxList(uint256) external returns (address);\n\n    function allowedOutboxList(uint256) external returns (address);\n\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    function delayedInboxAccs(uint256) external view returns (bytes32);\n\n    /// @dev Accumulator for sequencer inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    function sequencerInboxAccs(uint256) external view returns (bytes32);\n\n    function rollup() external view returns (IOwnable);\n\n    function sequencerInbox() external view returns (address);\n\n    function activeOutbox() external view returns (address);\n\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function sequencerReportedSubMessageCount() external view returns (uint256);\n\n    function executeCall(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    function delayedMessageCount() external view returns (uint256);\n\n    function sequencerMessageCount() external view returns (uint256);\n\n    // ---------- onlySequencerInbox functions ----------\n\n    function enqueueSequencerMessage(\n        bytes32 dataHash,\n        uint256 afterDelayedMessagesRead,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    )\n        external\n        returns (\n            uint256 seqMessageIndex,\n            bytes32 beforeAcc,\n            bytes32 delayedAcc,\n            bytes32 acc\n        );\n\n    /**\n     * @dev Allows the sequencer inbox to submit a delayed message of the batchPostingReport type\n     *      This is done through a separate function entrypoint instead of allowing the sequencer inbox\n     *      to call `enqueueDelayedMessage` to avoid the gas overhead of an extra SLOAD in either\n     *      every delayed inbox or every sequencer inbox call.\n     */\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\n        external\n        returns (uint256 msgNum);\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    function setSequencerInbox(address _sequencerInbox) external;\n\n    function setDelayedInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    function updateRollupAddress(IOwnable _rollup) external;\n}\n"
			},
			"node_modules/@arbitrum/nitro-contracts/src/bridge/IDelayedMessageProvider.sol": {
				"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\ninterface IDelayedMessageProvider {\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\n    /// same as InboxMessageDelivered but the batch data is available in tx.input\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n"
			},
			"node_modules/@arbitrum/nitro-contracts/src/bridge/IInbox.sol": {
				"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\nimport \"./IBridge.sol\";\nimport \"./IInboxBase.sol\";\n\ninterface IInbox is IInboxBase {\n    function sendL1FundedUnsignedTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function sendL1FundedContractTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        address to,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @dev This method can only be called upon L1 fork and will not alias the caller\n     *      This method will revert if not called from origin\n     */\n    function sendL1FundedUnsignedTransactionToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @dev This method can only be called upon L1 fork and will not alias the caller\n     *      This method will revert if not called from origin\n     */\n    function sendUnsignedTransactionToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (uint256);\n\n    /**\n     * @notice Send a message to initiate L2 withdrawal\n     * @dev This method can only be called upon L1 fork and will not alias the caller\n     *      This method will revert if not called from origin\n     */\n    function sendWithdrawEthToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        uint256 value,\n        address withdrawTo\n    ) external returns (uint256);\n\n    /**\n     * @notice Deposit eth from L1 to L2 to address of the sender if sender is an EOA, and to its aliased address if the sender is a contract\n     * @dev This does not trigger the fallback function when receiving in the L2 side.\n     *      Look into retryable tickets if you are interested in this functionality.\n     * @dev This function should not be called inside contract constructors\n     */\n    function depositEth() external payable returns (uint256);\n\n    /**\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of L2 message\n     * @return unique message number of the retryable transaction\n     */\n    function createRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed funds\n     * come from the deposit alone, rather than falling back on the user's L2 balance\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\n     * createRetryableTicket method is the recommended standard.\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of L2 message\n     * @return unique message number of the retryable transaction\n     */\n    function unsafeCreateRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    // ---------- initializer ----------\n\n    /**\n     * @dev function to be called one time during the inbox upgrade process\n     *      this is used to fix the storage slots\n     */\n    function postUpgradeInit(IBridge _bridge) external;\n}\n"
			},
			"node_modules/@arbitrum/nitro-contracts/src/bridge/IInboxBase.sol": {
				"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\nimport \"./IBridge.sol\";\nimport \"./IDelayedMessageProvider.sol\";\nimport \"./ISequencerInbox.sol\";\n\ninterface IInboxBase is IDelayedMessageProvider {\n    function bridge() external view returns (IBridge);\n\n    function sequencerInbox() external view returns (ISequencerInbox);\n\n    function maxDataSize() external view returns (uint256);\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\n     * @param messageData Data of the message being sent\n     */\n    function sendL2MessageFromOrigin(bytes calldata messageData) external returns (uint256);\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\n     * @param messageData Data of the message being sent\n     */\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n    function sendUnsignedTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendContractTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (uint256);\n\n    /**\n     * @notice Get the L1 fee for submitting a retryable\n     * @dev This fee can be paid by funds already in the L2 aliased address or by the current message value\n     * @dev This formula may change in the future, to future proof your code query this method instead of inlining!!\n     * @param dataLength The length of the retryable's calldata, in bytes\n     * @param baseFee The block basefee when the retryable is included in the chain, if 0 current block.basefee will be used\n     */\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\n        external\n        view\n        returns (uint256);\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    /// @notice pauses all inbox functionality\n    function pause() external;\n\n    /// @notice unpauses all inbox functionality\n    function unpause() external;\n\n    /// @notice add or remove users from allowList\n    function setAllowList(address[] memory user, bool[] memory val) external;\n\n    /// @notice enable or disable allowList\n    function setAllowListEnabled(bool _allowListEnabled) external;\n\n    /// @notice check if user is in allowList\n    function isAllowed(address user) external view returns (bool);\n\n    /// @notice check if allowList is enabled\n    function allowListEnabled() external view returns (bool);\n\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox) external;\n\n    /// @notice returns the current admin\n    function getProxyAdmin() external view returns (address);\n}\n"
			},
			"node_modules/@arbitrum/nitro-contracts/src/bridge/IOutbox.sol": {
				"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\nimport \"./IBridge.sol\";\n\ninterface IOutbox {\n    event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash);\n    event OutBoxTransactionExecuted(\n        address indexed to,\n        address indexed l2Sender,\n        uint256 indexed zero,\n        uint256 transactionIndex\n    );\n\n    function initialize(IBridge _bridge) external;\n\n    function rollup() external view returns (address); // the rollup contract\n\n    function bridge() external view returns (IBridge); // the bridge contract\n\n    function spent(uint256) external view returns (bytes32); // packed spent bitmap\n\n    function roots(bytes32) external view returns (bytes32); // maps root hashes => L2 block hash\n\n    // solhint-disable-next-line func-name-mixedcase\n    function OUTBOX_VERSION() external view returns (uint128); // the outbox version\n\n    function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) external;\n\n    function updateRollupAddress() external;\n\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\n    ///         When the return value is zero, that means this is a system message\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\n    function l2ToL1Sender() external view returns (address);\n\n    /// @return l2Block return L2 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1Block() external view returns (uint256);\n\n    /// @return l1Block return L1 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1EthBlock() external view returns (uint256);\n\n    /// @return timestamp return L2 timestamp when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1Timestamp() external view returns (uint256);\n\n    /// @return outputId returns the unique output identifier of the L2 to L1 tx or 0 if no L2 to L1 transaction is active\n    function l2ToL1OutputId() external view returns (bytes32);\n\n    /**\n     * @notice Executes a messages in an Outbox entry.\n     * @dev Reverts if dispute period hasn't expired, since the outbox entry\n     *      is only created once the rollup confirms the respective assertion.\n     * @dev it is not possible to execute any L2-to-L1 transaction which contains data\n     *      to a contract address without any code (as enforced by the Bridge contract).\n     * @param proof Merkle proof of message inclusion in send root\n     * @param index Merkle path to message\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\n     * @param to destination address for L1 contract call\n     * @param l2Block l2 block number at which sendTxToL1 call was made\n     * @param l1Block l1 block number at which sendTxToL1 call was made\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\n     * @param value wei in L1 message\n     * @param data abi-encoded L1 message data\n     */\n    function executeTransaction(\n        bytes32[] calldata proof,\n        uint256 index,\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n     *  @dev function used to simulate the result of a particular function call from the outbox\n     *       it is useful for things such as gas estimates. This function includes all costs except for\n     *       proof validation (which can be considered offchain as a somewhat of a fixed cost - it's\n     *       not really a fixed cost, but can be treated as so with a fixed overhead for gas estimation).\n     *       We can't include the cost of proof validation since this is intended to be used to simulate txs\n     *       that are included in yet-to-be confirmed merkle roots. The simulation entrypoint could instead pretend\n     *       to confirm a pending merkle root, but that would be less practical for integrating with tooling.\n     *       It is only possible to trigger it when the msg sender is address zero, which should be impossible\n     *       unless under simulation in an eth_call or eth_estimateGas\n     */\n    function executeTransactionSimulation(\n        uint256 index,\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @param index Merkle path to message\n     * @return true if the message has been spent\n     */\n    function isSpent(uint256 index) external view returns (bool);\n\n    function calculateItemHash(\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external pure returns (bytes32);\n\n    function calculateMerkleRoot(\n        bytes32[] memory proof,\n        uint256 path,\n        bytes32 item\n    ) external pure returns (bytes32);\n\n    /**\n     * @dev function to be called one time during the outbox upgrade process\n     *      this is used to fix the storage slots\n     */\n    function postUpgradeInit() external;\n}\n"
			},
			"node_modules/@arbitrum/nitro-contracts/src/bridge/IOwnable.sol": {
				"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.21 <0.9.0;\n\ninterface IOwnable {\n    function owner() external view returns (address);\n}\n"
			},
			"node_modules/@arbitrum/nitro-contracts/src/bridge/ISequencerInbox.sol": {
				"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../libraries/IGasRefunder.sol\";\nimport \"./IDelayedMessageProvider.sol\";\nimport \"./IBridge.sol\";\n\ninterface ISequencerInbox is IDelayedMessageProvider {\n    struct MaxTimeVariation {\n        uint256 delayBlocks;\n        uint256 futureBlocks;\n        uint256 delaySeconds;\n        uint256 futureSeconds;\n    }\n\n    event SequencerBatchDelivered(\n        uint256 indexed batchSequenceNumber,\n        bytes32 indexed beforeAcc,\n        bytes32 indexed afterAcc,\n        bytes32 delayedAcc,\n        uint256 afterDelayedMessagesRead,\n        IBridge.TimeBounds timeBounds,\n        IBridge.BatchDataLocation dataLocation\n    );\n\n    event OwnerFunctionCalled(uint256 indexed id);\n\n    /// @dev a separate event that emits batch data when this isn't easily accessible in the tx.input\n    event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data);\n\n    /// @dev a valid keyset was added\n    event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes);\n\n    /// @dev a keyset was invalidated\n    event InvalidateKeyset(bytes32 indexed keysetHash);\n\n    function totalDelayedMessagesRead() external view returns (uint256);\n\n    function bridge() external view returns (IBridge);\n\n    /// @dev The size of the batch header\n    // solhint-disable-next-line func-name-mixedcase\n    function HEADER_LENGTH() external view returns (uint256);\n\n    /// @dev If the first batch data byte after the header has this bit set,\n    ///      the sequencer inbox has authenticated the data. Currently only used for 4844 blob support.\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function DATA_AUTHENTICATED_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data is to be found in 4844 data blobs\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function DATA_BLOB_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data is a das message\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function DAS_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data is a das message that employs a merklesization strategy\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function TREE_DAS_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data has been brotli compressed\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function BROTLI_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data uses a zero heavy encoding\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function ZERO_HEAVY_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    function rollup() external view returns (IOwnable);\n\n    function isBatchPoster(address) external view returns (bool);\n\n    function isSequencer(address) external view returns (bool);\n\n    function maxDataSize() external view returns (uint256);\n\n    /// @notice The batch poster manager has the ability to change the batch poster addresses\n    ///         This enables the batch poster to do key rotation\n    function batchPosterManager() external view returns (address);\n\n    struct DasKeySetInfo {\n        bool isValidKeyset;\n        uint64 creationBlock;\n    }\n\n    /// @dev returns 4 uint256 to be compatible with older version\n    function maxTimeVariation()\n        external\n        view\n        returns (\n            uint256 delayBlocks,\n            uint256 futureBlocks,\n            uint256 delaySeconds,\n            uint256 futureSeconds\n        );\n\n    function dasKeySetInfo(bytes32) external view returns (bool, uint64);\n\n    /// @notice Remove force inclusion delay after a L1 chainId fork\n    function removeDelayAfterFork() external;\n\n    /// @notice Force messages from the delayed inbox to be included in the chain\n    ///         Callable by any address, but message can only be force-included after maxTimeVariation.delayBlocks and\n    ///         maxTimeVariation.delaySeconds has elapsed. As part of normal behaviour the sequencer will include these\n    ///         messages so it's only necessary to call this if the sequencer is down, or not including any delayed messages.\n    /// @param _totalDelayedMessagesRead The total number of messages to read up to\n    /// @param kind The kind of the last message to be included\n    /// @param l1BlockAndTime The l1 block and the l1 timestamp of the last message to be included\n    /// @param baseFeeL1 The l1 gas price of the last message to be included\n    /// @param sender The sender of the last message to be included\n    /// @param messageDataHash The messageDataHash of the last message to be included\n    function forceInclusion(\n        uint256 _totalDelayedMessagesRead,\n        uint8 kind,\n        uint64[2] calldata l1BlockAndTime,\n        uint256 baseFeeL1,\n        address sender,\n        bytes32 messageDataHash\n    ) external;\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function batchCount() external view returns (uint256);\n\n    function isValidKeysetHash(bytes32 ksHash) external view returns (bool);\n\n    /// @notice the creation block is intended to still be available after a keyset is deleted\n    function getKeysetCreationBlock(bytes32 ksHash) external view returns (uint256);\n\n    // ---------- BatchPoster functions ----------\n\n    function addSequencerL2BatchFromOrigin(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder\n    ) external;\n\n    function addSequencerL2BatchFromOrigin(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external;\n\n    function addSequencerL2Batch(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external;\n\n    function addSequencerL2BatchFromBlobs(\n        uint256 sequenceNumber,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external;\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    /**\n     * @notice Set max delay for sequencer inbox\n     * @param maxTimeVariation_ the maximum time variation parameters\n     */\n    function setMaxTimeVariation(MaxTimeVariation memory maxTimeVariation_) external;\n\n    /**\n     * @notice Updates whether an address is authorized to be a batch poster at the sequencer inbox\n     * @param addr the address\n     * @param isBatchPoster_ if the specified address should be authorized as a batch poster\n     */\n    function setIsBatchPoster(address addr, bool isBatchPoster_) external;\n\n    /**\n     * @notice Makes Data Availability Service keyset valid\n     * @param keysetBytes bytes of the serialized keyset\n     */\n    function setValidKeyset(bytes calldata keysetBytes) external;\n\n    /**\n     * @notice Invalidates a Data Availability Service keyset\n     * @param ksHash hash of the keyset\n     */\n    function invalidateKeysetHash(bytes32 ksHash) external;\n\n    /**\n     * @notice Updates whether an address is authorized to be a sequencer.\n     * @dev The IsSequencer information is used only off-chain by the nitro node to validate sequencer feed signer.\n     * @param addr the address\n     * @param isSequencer_ if the specified address should be authorized as a sequencer\n     */\n    function setIsSequencer(address addr, bool isSequencer_) external;\n\n    /**\n     * @notice Updates the batch poster manager, the address which has the ability to rotate batch poster keys\n     * @param newBatchPosterManager The new batch poster manager to be set\n     */\n    function setBatchPosterManager(address newBatchPosterManager) external;\n\n    /// @notice Allows the rollup owner to sync the rollup address\n    function updateRollupAddress() external;\n\n    // ---------- initializer ----------\n\n    function initialize(IBridge bridge_, MaxTimeVariation calldata maxTimeVariation_) external;\n}\n"
			},
			"node_modules/@arbitrum/nitro-contracts/src/libraries/AddressAliasHelper.sol": {
				"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nlibrary AddressAliasHelper {\n    uint160 internal constant OFFSET = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + OFFSET);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - OFFSET);\n        }\n    }\n}\n"
			},
			"node_modules/@arbitrum/nitro-contracts/src/libraries/IGasRefunder.sol": {
				"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\ninterface IGasRefunder {\n    function onGasSpent(\n        address payable spender,\n        uint256 gasUsed,\n        uint256 calldataSize\n    ) external returns (bool success);\n}\n"
			},
			"node_modules/@arbitrum/nitro-contracts/src/precompiles/ArbSys.sol": {
				"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.4.21 <0.9.0;\n\n/**\n * @title System level functionality\n * @notice For use by contracts to interact with core L2-specific functionality.\n * Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064.\n */\ninterface ArbSys {\n    /**\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\n     * @return block number as int\n     */\n    function arbBlockNumber() external view returns (uint256);\n\n    /**\n     * @notice Get Arbitrum block hash (reverts unless currentBlockNum-256 <= arbBlockNum < currentBlockNum)\n     * @return block hash\n     */\n    function arbBlockHash(uint256 arbBlockNum) external view returns (bytes32);\n\n    /**\n     * @notice Gets the rollup's unique chain identifier\n     * @return Chain identifier as int\n     */\n    function arbChainID() external view returns (uint256);\n\n    /**\n     * @notice Get internal version number identifying an ArbOS build\n     * @return version number as int\n     */\n    function arbOSVersion() external view returns (uint256);\n\n    /**\n     * @notice Returns 0 since Nitro has no concept of storage gas\n     * @return uint 0\n     */\n    function getStorageGasAvailable() external view returns (uint256);\n\n    /**\n     * @notice (deprecated) check if current call is top level (meaning it was triggered by an EoA or a L1 contract)\n     * @dev this call has been deprecated and may be removed in a future release\n     * @return true if current execution frame is not a call by another L2 contract\n     */\n    function isTopLevelCall() external view returns (bool);\n\n    /**\n     * @notice map L1 sender contract address to its L2 alias\n     * @param sender sender address\n     * @param unused argument no longer used\n     * @return aliased sender address\n     */\n    function mapL1SenderContractAddressToL2Alias(address sender, address unused)\n        external\n        pure\n        returns (address);\n\n    /**\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\n     * @return true iff the caller's address is an alias for an L1 contract address\n     */\n    function wasMyCallersAddressAliased() external view returns (bool);\n\n    /**\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\n     * @return address of the caller's caller, without applying L1 contract address aliasing\n     */\n    function myCallersAddressWithoutAliasing() external view returns (address);\n\n    /**\n     * @notice Send given amount of Eth to dest from sender.\n     * This is a convenience function, which is equivalent to calling sendTxToL1 with empty data.\n     * @param destination recipient address on L1\n     * @return unique identifier for this L2-to-L1 transaction.\n     */\n    function withdrawEth(address destination) external payable returns (uint256);\n\n    /**\n     * @notice Send a transaction to L1\n     * @dev it is not possible to execute on the L1 any L2-to-L1 transaction which contains data\n     * to a contract address without any code (as enforced by the Bridge contract).\n     * @param destination recipient address on L1\n     * @param data (optional) calldata for L1 contract call\n     * @return a unique identifier for this L2-to-L1 transaction.\n     */\n    function sendTxToL1(address destination, bytes calldata data)\n        external\n        payable\n        returns (uint256);\n\n    /**\n     * @notice Get send Merkle tree state\n     * @return size number of sends in the history\n     * @return root root hash of the send history\n     * @return partials hashes of partial subtrees in the send history tree\n     */\n    function sendMerkleTreeState()\n        external\n        view\n        returns (\n            uint256 size,\n            bytes32 root,\n            bytes32[] memory partials\n        );\n\n    /**\n     * @notice creates a send txn from L2 to L1\n     * @param position = (level << 192) + leaf = (0 << 192) + leaf = leaf\n     */\n    event L2ToL1Tx(\n        address caller,\n        address indexed destination,\n        uint256 indexed hash,\n        uint256 indexed position,\n        uint256 arbBlockNum,\n        uint256 ethBlockNum,\n        uint256 timestamp,\n        uint256 callvalue,\n        bytes data\n    );\n\n    /// @dev DEPRECATED in favour of the new L2ToL1Tx event above after the nitro upgrade\n    event L2ToL1Transaction(\n        address caller,\n        address indexed destination,\n        uint256 indexed uniqueId,\n        uint256 indexed batchNumber,\n        uint256 indexInBatch,\n        uint256 arbBlockNum,\n        uint256 ethBlockNum,\n        uint256 timestamp,\n        uint256 callvalue,\n        bytes data\n    );\n\n    /**\n     * @notice logs a merkle branch for proof synthesis\n     * @param reserved an index meant only to align the 4th index with L2ToL1Transaction's 4th event\n     * @param hash the merkle hash\n     * @param position = (level << 192) + leaf\n     */\n    event SendMerkleUpdate(\n        uint256 indexed reserved,\n        bytes32 indexed hash,\n        uint256 indexed position\n    );\n\n    error InvalidBlockNumber(uint256 requested, uint256 current);\n}\n"
			},
			"src/BPArbitrumSucker.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBTokens} from \"@bananapus/core/src/interfaces/IJBTokens.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {JBConstants} from \"@bananapus/core/src/libraries/JBConstants.sol\";\nimport {BitMaps} from \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\nimport {IBridge} from \"@arbitrum/nitro-contracts/src/bridge/IBridge.sol\";\nimport {IOutbox} from \"@arbitrum/nitro-contracts/src/bridge/IOutbox.sol\";\nimport {ArbSys} from \"@arbitrum/nitro-contracts/src/precompiles/ArbSys.sol\";\nimport {AddressAliasHelper} from \"@arbitrum/nitro-contracts/src/libraries/AddressAliasHelper.sol\";\nimport {IInbox} from \"@arbitrum/nitro-contracts/src/bridge/IInbox.sol\";\n\nimport {ArbL1GatewayRouter} from \"./interfaces/ArbL1GatewayRouter.sol\";\nimport {ArbL2GatewayRouter} from \"./interfaces/ArbL2GatewayRouter.sol\";\nimport {IArbGatewayRouter} from \"./interfaces/IArbGatewayRouter.sol\";\nimport {BPRemoteToken} from \"./structs/BPRemoteToken.sol\";\nimport {BPInboxTreeRoot} from \"./structs/BPInboxTreeRoot.sol\";\nimport {BPMessageRoot} from \"./structs/BPMessageRoot.sol\";\nimport {BPLayer} from \"./enums/BPLayer.sol\";\nimport {BPSucker, IBPSuckerDeployer, BPAddToBalanceMode} from \"./BPSucker.sol\";\nimport {BPArbitrumSuckerDeployer} from \"./deployers/BPArbitrumSuckerDeployer.sol\";\nimport {MerkleLib} from \"./utils/MerkleLib.sol\";\n\nimport {ARBAddresses} from \"./libraries/ARBAddresses.sol\";\nimport {ARBChains} from \"./libraries/ARBChains.sol\";\n\n/// @notice A `BPSucker` implementation to suck tokens between two chains connected by an Arbitrum bridge.\n// NOTICE: UNFINISHED!\ncontract BPArbitrumSucker is BPSucker {\n    error L1GatewayUnsupported();\n    error ChainNotSupported();\n    error NotEnoughGas();\n\n    using MerkleLib for MerkleLib.Tree;\n    using BitMaps for BitMaps.BitMap;\n\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    /// @notice The layer that this contract is on.\n    BPLayer public immutable LAYER;\n\n    /// @notice The gateway router for the specific chain\n    IArbGatewayRouter public immutable GATEWAYROUTER;\n\n    /// @notice The inbox used to send messages between the local and remote sucker.\n    IInbox public immutable ARBINBOX;\n\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n    constructor(\n        IJBDirectory directory,\n        IJBTokens tokens,\n        IJBPermissions permissions,\n        address peer,\n        BPAddToBalanceMode atbMode\n    ) BPSucker(directory, tokens, permissions, peer, atbMode, IBPSuckerDeployer(msg.sender).TEMP_ID_STORE()) {\n        // Layer specific properties\n        uint256 _chainId = block.chainid;\n\n        // If LAYER is left uninitialized, the chain is not currently supported.\n        if (!isSupportedChain(_chainId)) revert ChainNotSupported();\n\n        // Set LAYER based on the chain ID.\n        if (_chainId == ARBChains.ETH_CHAINID || _chainId == ARBChains.ETH_SEP_CHAINID) {\n            // Set the layer\n            LAYER = BPLayer.L1;\n\n            // Set the inbox depending on the chain\n            _chainId == ARBChains.ETH_CHAINID\n                ? ARBINBOX = IInbox(ARBAddresses.L1_ETH_INBOX)\n                : ARBINBOX = IInbox(ARBAddresses.L1_SEP_INBOX);\n        }\n        if (_chainId == ARBChains.ARB_CHAINID || _chainId == ARBChains.ARB_SEP_CHAINID) LAYER = BPLayer.L2;\n\n        GATEWAYROUTER = BPArbitrumSuckerDeployer(msg.sender).gatewayRouter();\n    }\n\n    //*********************************************************************//\n    // ------------------------ external views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Returns the chain on which the peer is located.\n    /// @return chainId of the peer.\n    function peerChainID() external view virtual override returns (uint256 chainId) {\n        uint256 _chainId = block.chainid;\n        if (_chainId == ARBChains.ETH_CHAINID) return ARBChains.ARB_CHAINID;\n        if (_chainId == ARBChains.ARB_CHAINID) return ARBChains.ETH_CHAINID;\n        if (_chainId == ARBChains.ETH_SEP_CHAINID) return ARBChains.ARB_SEP_CHAINID;\n        if (_chainId == ARBChains.ARB_SEP_CHAINID) return ARBChains.ETH_SEP_CHAINID;\n    }\n\n    //*********************************************************************//\n    // ------------------------ private views ---------------------------- //\n    //*********************************************************************//\n\n    /// @notice Returns true if the chainId is supported.\n    /// @return supported false/true if this is deployed on a supported chain.\n    function isSupportedChain(uint256 chainId) private pure returns (bool supported) {\n        return chainId == ARBChains.ETH_CHAINID || chainId == ARBChains.ETH_SEP_CHAINID\n            || chainId == ARBChains.ARB_CHAINID || chainId == ARBChains.ARB_SEP_CHAINID;\n    }\n\n    //*********************************************************************//\n    // --------------------- internal transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Uses the L1/L2 gateway to send the root and assets over the bridge to the peer.\n    /// @param transportPayment the amount of `msg.value` that is going to get paid for sending this message.\n    /// @param token The token to bridge the outbox tree for.\n    /// @param remoteToken Information about the remote token being bridged to.\n    function _sendRoot(uint256 transportPayment, address token, BPRemoteToken memory remoteToken) internal override {\n        // TODO: Handle the `transportPayment`\n        // if (transportPayment == 0) {\n        //     revert UNEXPECTED_MSG_VALUE();\n        // }\n\n        // Get the amount to send and then clear it.\n        uint256 amount = outbox[token].balance;\n        delete outbox[token].balance;\n\n        // Increment the outbox tree's nonce.\n        uint64 nonce = ++outbox[token].nonce;\n\n        if (remoteToken.addr == address(0)) {\n            revert TOKEN_NOT_MAPPED(token);\n        }\n\n        // Build the calldata that will be send to the peer. This will call `BPSucker.fromRemote` on the remote peer.\n        bytes memory data = abi.encodeCall(\n            BPSucker.fromRemote,\n            (\n                BPMessageRoot({\n                    token: remoteToken.addr,\n                    amount: amount,\n                    remoteRoot: BPInboxTreeRoot({nonce: nonce, root: outbox[token].tree.root()})\n                })\n            )\n        );\n\n        // Depending on which layer we are on, send the call to the other layer.\n        if (LAYER == BPLayer.L1) {\n            _toL2(token, transportPayment, amount, data, remoteToken);\n        } else {\n            _toL1(token, amount, data, remoteToken);\n        }\n\n        // Emit an event for the relayers to watch for.\n        emit RootToRemote(outbox[token].tree.root(), token, outbox[token].tree.count - 1, nonce);\n    }\n\n    /// @notice Bridge the `token` and data to the remote L1 chain.\n    /// @param token The token to bridge.\n    /// @param amount The amount of tokens to bridge.\n    /// @param data The calldata to send to the remote chain. This calls `BPSucker.fromRemote` on the remote peer.\n    /// @param remoteToken Information about the remote token to bridged to.\n    function _toL1(address token, uint256 amount, bytes memory data, BPRemoteToken memory remoteToken) internal {\n        uint256 nativeValue;\n\n        // Revert if there's a `msg.value`. Sending a message to L1 does not require any payment.\n        if (msg.value != 0) {\n            revert UNEXPECTED_MSG_VALUE();\n        }\n\n        // If the token is an ERC-20, bridge it to the peer.\n        if (token != JBConstants.NATIVE_TOKEN) {\n            SafeERC20.forceApprove(IERC20(token), GATEWAYROUTER.getGateway(token), amount);\n\n            ArbL2GatewayRouter(address(GATEWAYROUTER)).outboundTransfer(\n                remoteToken.addr, address(PEER), amount, bytes(\"\")\n            );\n        } else {\n            // Otherwise, the token is the native token, and the amount will be sent as `msg.value`.\n            nativeValue = amount;\n        }\n\n        // Send the message to the peer with the redeemed ETH.\n        // Address `100` is the ArbSys precompile address.\n        ArbSys(address(100)).sendTxToL1{value: nativeValue}(address(PEER), data);\n    }\n\n    /// @notice Bridge the `token` and data to the remote L2 chain.\n    /// @param token The token to bridge.\n    /// @param amount The amount of tokens to bridge.\n    /// @param data The calldata to send to the remote chain. This calls `BPSucker.fromRemote` on the remote peer.\n    function _toL2(\n        address token,\n        uint256 transportPayment,\n        uint256 amount,\n        bytes memory data,\n        BPRemoteToken memory /* remoteToken */\n    ) internal {\n        uint256 nativeValue;\n        uint256 _maxSubmissionCost = ARBINBOX.calculateRetryableSubmissionFee(data.length, 0.2 gwei);\n        uint256 _feeTotal = _maxSubmissionCost + (MESSENGER_BASE_GAS_LIMIT * 0.2 gwei);\n\n        // Ensure we bridge enough for gas costs on L2 side\n        if (transportPayment < _feeTotal) revert NotEnoughGas();\n\n        // If the token is an ERC-20, bridge it to the peer.\n        if (token != JBConstants.NATIVE_TOKEN) {\n            // Approve the tokens to be bridged.\n            SafeERC20.forceApprove(IERC20(token), GATEWAYROUTER.getGateway(token), amount);\n\n            // Perform the ERC-20 bridge transfer.\n            ArbL1GatewayRouter(address(GATEWAYROUTER)).outboundTransferCustomRefund{value: transportPayment}({\n                _token: token,\n                _refundTo: msg.sender,\n                _to: address(PEER),\n                _amount: amount,\n                _maxGas: MESSENGER_BASE_GAS_LIMIT, // minimum appears to be 275000 per their sdk - MESSENGER_BASE_GAS_LIMIT = 300k here\n                _gasPriceBid: 0.2 gwei, // sane enough for now - covers moderate congestion, maybe decide client side in the future\n                _data: bytes(abi.encode(_maxSubmissionCost, data)) // @note: maybe this is zero if we pay with msg.value? we'll see in testing\n            });\n        } else {\n            // Otherwise, the token is the native token, and the amount will be sent as `msg.value`.\n            nativeValue = amount;\n        }\n\n        // Ensure we bridge enough for gas costs on L2 side\n        // transportPayment is ref of msg.value\n        if (nativeValue + _feeTotal > transportPayment) revert NotEnoughGas();\n\n        // Create the retryable ticket containing the merkleRoot.\n        // TODO: We could even make this unsafe.\n        ARBINBOX.createRetryableTicket{value: transportPayment}({\n            to: address(PEER),\n            l2CallValue: nativeValue,\n            maxSubmissionCost: _maxSubmissionCost,\n            excessFeeRefundAddress: msg.sender,\n            callValueRefundAddress: msg.sender,\n            gasLimit: MESSENGER_BASE_GAS_LIMIT,\n            maxFeePerGas: 0.2 gwei,\n            data: data\n        });\n    }\n\n    /// @notice Checks if the `sender` (`msg.sender`) is a valid representative of the remote peer.\n    /// @param sender The message's sender.\n    function _isRemotePeer(address sender) internal view override returns (bool _valid) {\n        // If we are the L1 peer,\n        if (LAYER == BPLayer.L1) {\n            IBridge bridge = ARBINBOX.bridge();\n            // Check that the sender is the bridge and that the outbox has our peer as the sender.\n            return sender == address(bridge) && address(PEER) == IOutbox(bridge.activeOutbox()).l2ToL1Sender();\n        }\n\n        // If we are the L2 peer, check using the `AddressAliasHelper`.\n        return sender == AddressAliasHelper.applyL1ToL2Alias(address(PEER));\n    }\n}\n"
			},
			"src/deployers/BPArbitrumSuckerDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBPermissioned} from \"@bananapus/core/src/abstract/JBPermissioned.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBRulesets} from \"@bananapus/core/src/interfaces/IJBRulesets.sol\";\nimport {IJBTokens} from \"@bananapus/core/src/interfaces/IJBTokens.sol\";\nimport {IInbox} from \"@arbitrum/nitro-contracts/src/bridge/IInbox.sol\";\nimport {BPArbitrumSucker} from \"../BPArbitrumSucker.sol\";\nimport {BPAddToBalanceMode} from \"../enums/BPAddToBalanceMode.sol\";\nimport {IBPSucker} from \"./../interfaces/IBPSucker.sol\";\nimport {IBPSuckerDeployer} from \"./../interfaces/IBPSuckerDeployer.sol\";\n\nimport {ARBAddresses} from \"../libraries/ARBAddresses.sol\";\nimport {ARBChains} from \"../libraries/ARBChains.sol\";\nimport {BPLayer} from \"../enums/BPLayer.sol\";\nimport {IArbGatewayRouter} from \"../interfaces/IArbGatewayRouter.sol\";\n\n/// @notice An `IBPSuckerDeployerFeeless` implementation to deploy `BPOptimismSucker` contracts.\ncontract BPArbitrumSuckerDeployer is JBPermissioned, IBPSuckerDeployer {\n    error ONLY_SUCKERS();\n    error ALREADY_CONFIGURED();\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory immutable DIRECTORY;\n\n    /// @notice The contract that manages token minting and burning.\n    IJBTokens immutable TOKENS;\n\n    /// @notice A mapping of suckers deployed by this contract.\n    mapping(address => bool) public isSucker;\n\n    //*********************************************************************//\n    // ---------------- layer specific stored properties ----------------- //\n    //*********************************************************************//\n\n    /// @notice The layer that this contract is on.\n    BPLayer public immutable LAYER;\n\n    /// @notice Only this address can configure this deployer, can only be used once.\n    address immutable LAYER_SPECIFIC_CONFIGURATOR;\n\n    /// @notice A temporary storage slot used by suckers to maintain deterministic deploys.\n    uint256 public TEMP_ID_STORE;\n\n    constructor(IJBDirectory directory, IJBTokens tokens, IJBPermissions permissions, address _configurator)\n        JBPermissioned(permissions)\n    {\n        LAYER_SPECIFIC_CONFIGURATOR = _configurator;\n        DIRECTORY = directory;\n        TOKENS = tokens;\n    }\n\n    /// @notice Create a new `BPSucker` for a specific project.\n    /// @dev Uses the sender address as the salt, which means the same sender must call this function on both chains.\n    /// @param localProjectId The project's ID on the local chain.\n    /// @param salt The salt to use for the `create2` address.\n    /// @return sucker The address of the new sucker.\n    function createForSender(uint256 localProjectId, bytes32 salt) external returns (IBPSucker sucker) {\n        salt = keccak256(abi.encodePacked(msg.sender, salt));\n\n        // Set for a callback to this contract.\n        TEMP_ID_STORE = localProjectId;\n\n        sucker = IBPSucker(\n            address(\n                new BPArbitrumSucker{salt: salt}(DIRECTORY, TOKENS, PERMISSIONS, address(0), BPAddToBalanceMode.MANUAL)\n            )\n        );\n\n        // TODO: See if resetting this value is cheaper than deletion\n        // Delete after callback should complete.\n        /* delete TEMP_ID_STORE; */\n\n        isSucker[address(sucker)] = true;\n    }\n\n    //*********************************************************************//\n    // ------------------------ external views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Returns the gateway router address for the current chain\n    /// @return gateway for the current chain.\n    function gatewayRouter() external view returns (IArbGatewayRouter gateway) {\n        uint256 _chainId = block.chainid;\n        if (_chainId == ARBChains.ETH_CHAINID) return IArbGatewayRouter(ARBAddresses.L1_GATEWAY_ROUTER);\n        if (_chainId == ARBChains.ARB_CHAINID) return IArbGatewayRouter(ARBAddresses.L2_GATEWAY_ROUTER);\n        if (_chainId == ARBChains.ETH_SEP_CHAINID) return IArbGatewayRouter(ARBAddresses.L1_SEP_GATEWAY_ROUTER);\n        if (_chainId == ARBChains.ARB_SEP_CHAINID) return IArbGatewayRouter(ARBAddresses.L2_SEP_GATEWAY_ROUTER);\n    }\n\n    /* /// @notice handles some layer specific configuration that can't be done in the constructor otherwise deployment addresses would change.\n    /// @notice messenger the OPMesssenger on this layer.\n    /// @notice bridge the OPStandardBridge on this layer.\n    function configureLayerSpecific(OPMessenger messenger, OPStandardBridge bridge) external {\n        if (address(MESSENGER) != address(0) || address(BRIDGE) != address(0)) {\n            revert ALREADY_CONFIGURED();\n        }\n        // Configure these layer specific properties.\n        // This is done in a seperate call to make the deployment code chain agnostic.\n        MESSENGER = messenger;\n        BRIDGE = INBOX.bridge();\n    } */\n}\n"
			},
			"src/enums/BPLayer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Whether a `BPArbitrumSucker` is on L1 or L2.\nenum BPLayer {\n    L1,\n    L2\n}\n"
			},
			"src/interfaces/ArbL1GatewayRouter.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ArbL1GatewayRouter {\n    function outboundTransferCustomRefund(\n        address _token,\n        address _refundTo,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n}\n"
			},
			"src/interfaces/ArbL2GatewayRouter.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ArbL2GatewayRouter {\n    function outboundTransfer(address _l1Token, address _to, uint256 _amount, bytes calldata _data)\n        external\n        payable\n        returns (bytes memory);\n}\n"
			},
			"src/interfaces/IArbGatewayRouter.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Common interface for L1 and L2 Gateway Routers\n */\ninterface IArbGatewayRouter {\n    function defaultGateway() external view returns (address gateway);\n\n    function getGateway(address _token) external view returns (address gateway);\n}\n"
			},
			"src/libraries/ARBAddresses.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/// @notice Global constants used across Juicebox contracts.\nlibrary ARBAddresses {\n    /// @notice The respective Inbox used by L1 or Testnet L1\n    address public constant L1_ETH_INBOX = 0x4Dbd4fc535Ac27206064B68FfCf827b0A60BAB3f;\n    address public constant L1_SEP_INBOX = 0xaAe29B0366299461418F5324a79Afc425BE5ae21;\n\n    /// @notice The gateway router used to bridge tokens between the local and remote chain.\n    address public constant L1_GATEWAY_ROUTER = 0x72Ce9c846789fdB6fC1f34aC4AD25Dd9ef7031ef;\n    address public constant L2_GATEWAY_ROUTER = 0x5288c571Fd7aD117beA99bF60FE0846C4E84F933;\n\n    /// @notice The testnet gateway routers used for briding tokens.\n    address public constant L1_SEP_GATEWAY_ROUTER = 0xcE18836b233C83325Cc8848CA4487e94C6288264;\n    address public constant L2_SEP_GATEWAY_ROUTER = 0x9fDD1C4E4AA24EEc1d913FABea925594a20d43C7;\n}\n"
			},
			"src/libraries/ARBChains.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/// @notice Global constants used across Juicebox contracts.\nlibrary ARBChains {\n    /// @notice Arbitrum relevant chains and their respective ids.\n    uint256 public constant ETH_CHAINID = 1;\n    uint256 public constant ETH_SEP_CHAINID = 11155111;\n    uint256 public constant ARB_CHAINID = 42161;\n    uint256 public constant ARB_SEP_CHAINID = 421614;\n}\n"
			},
			"node_modules/@bananapus/ownable/src/JBOwnable.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// Juicebox variation on OpenZeppelin Ownable\npragma solidity ^0.8.23;\n\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\n\nimport {JBOwnableOverrides} from \"./JBOwnableOverrides.sol\";\n\ncontract JBOwnable is JBOwnableOverrides {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @param projects The `IJBProjects` to use for tracking project ownership.\n    /// @param permissions The `IJBPermissions` to use for managing permissions.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param initialProjectIdOwner The initial project id that owns this contract.\n    constructor(\n        IJBProjects projects,\n        IJBPermissions permissions,\n        address initialOwner,\n        uint88 initialProjectIdOwner\n    )\n        JBOwnableOverrides(projects, permissions, initialOwner, initialProjectIdOwner)\n    {}\n\n    /// @notice Reverts if called by an address that is not the owner and does not have permission from the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n\n    function _emitTransferEvent(\n        address previousOwner,\n        address newOwner,\n        uint88 newProjectId\n    )\n        internal\n        virtual\n        override\n    {\n        emit OwnershipTransferred(previousOwner, newProjectId == 0 ? newOwner : PROJECTS.ownerOf(newProjectId));\n    }\n}\n"
			},
			"node_modules/@bananapus/ownable/src/JBOwnableOverrides.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// Juicebox variation on OpenZeppelin Ownable\npragma solidity ^0.8.23;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {JBPermissioned, IJBPermissions} from \"@bananapus/core/src/abstract/JBPermissioned.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\n\nimport {JBOwner} from \"./struct/JBOwner.sol\";\nimport {IJBOwnable} from \"./interfaces/IJBOwnable.sol\";\n\n/// @notice Access control module to grant exclusive access to a specified address (the owner) for specific functions.\n/// The owner can also grant access permissions to other addresses via `JBPermissions`.\n/// @dev Inherit this contract to make the `onlyOwner` modifier available. When applied to a function, this modifier\n/// restricts use to the owner and addresses with the appropriate permission from the owner.\nabstract contract JBOwnableOverrides is Context, JBPermissioned, IJBOwnable {\n    //*********************************************************************//\n    // --------------------------- custom errors --------------------------//\n    //*********************************************************************//b\n\n    error INVALID_NEW_OWNER();\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable PROJECTS;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice This contract's owner information.\n    JBOwner public override jbOwner;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param projects The `IJBProjects` to use for tracking project ownership.\n    /// @param permissions The `IJBPermissions` to use for managing permissions.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param initialProjectIdOwner The initial project id that owns this contract.\n    constructor(\n        IJBProjects projects,\n        IJBPermissions permissions,\n        address initialOwner,\n        uint88 initialProjectIdOwner\n    )\n        JBPermissioned(permissions)\n    {\n        PROJECTS = projects;\n\n        // We force the inheriting contract to set an owner, as there is a\n        // low chance someone will use `JBOwnable` to create an unowned contract.\n        // But a higher chance that both are accidentally set to be `0`.\n        // If you really want an unowned contract, set the owner to any address then renounce in the constructor body.\n        if (initialProjectIdOwner == 0 && initialOwner == address(0)) {\n            revert INVALID_NEW_OWNER();\n        }\n\n        _transferOwnership(initialOwner, initialProjectIdOwner);\n    }\n\n    //*********************************************************************//\n    // --------------------------- public methods ------------------------ //\n    //*********************************************************************//\n\n    /// @notice Returns the owner's address based on this contract's `JBOwner` owner information.\n    function owner() public view virtual returns (address) {\n        JBOwner memory ownerInfo = jbOwner;\n\n        if (ownerInfo.projectId == 0) {\n            return ownerInfo.owner;\n        }\n\n        return PROJECTS.ownerOf(ownerInfo.projectId);\n    }\n\n    /// @notice Gives up ownership of this contract, making it impossible to call `onlyOwner`/`_checkOwner` functions.\n    /// Can only be called by the current owner.\n    function renounceOwnership() public virtual {\n        _checkOwner();\n        _transferOwnership(address(0), 0);\n    }\n\n    /// @notice Transfers ownership of this contract to a new account (the `newOwner`). Can only be called by the\n    /// current owner.\n    /// @param newOwner The address that should receive ownership of this contract.\n    function transferOwnership(address newOwner) public virtual {\n        _checkOwner();\n        if (newOwner == address(0)) {\n            revert INVALID_NEW_OWNER();\n        }\n\n        _transferOwnership(newOwner, 0);\n    }\n\n    /// @notice Transfer ownership of this contract to a new Juicebox project.\n    /// @dev The `projectId` must fit within a `uint88`.\n    /// @param projectId The ID of the project that should receive ownership of this contract.\n    function transferOwnershipToProject(uint256 projectId) public virtual {\n        _checkOwner();\n        if (projectId == 0 || projectId > type(uint88).max) {\n            revert INVALID_NEW_OWNER();\n        }\n\n        _transferOwnership(address(0), uint88(projectId));\n    }\n\n    /// @notice Sets the permission ID which, when granted from the owner, allows other addresses to perform operations\n    /// on their behalf.\n    /// @param permissionId The ID of the permission to use for `onlyOwner`.\n    function setPermissionId(uint8 permissionId) public virtual {\n        _checkOwner();\n        _setPermissionId(permissionId);\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal methods ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Sets the permission ID which, when granted from the owner, allows other addresses to perform operations\n    /// on their behalf.\n    /// @dev Internal function without access restriction.\n    /// @param permissionId The ID of the permission to use for `onlyOwner`.\n    function _setPermissionId(uint8 permissionId) internal virtual {\n        jbOwner.permissionId = permissionId;\n        emit PermissionIdChanged(permissionId);\n    }\n\n    /// @notice Helper to allow for drop-in replacement of OpenZeppelin.\n    /// @param newOwner The address that should receive ownership of this contract.\n    function _transferOwnership(address newOwner) internal virtual {\n        _transferOwnership(newOwner, 0);\n    }\n\n    /// @notice Transfers this contract's ownership to an address (`newOwner`) OR a Juicebox project (`projectId`).\n    /// @dev Updates this contract's `JBOwner` owner information.\n    /// @dev If both `newOwner` and `projectId` are set, this will revert.\n    /// @dev Internal function without access restriction.\n    /// @param newOwner The address that should receive ownership of this contract.\n    /// @param projectId The ID of the project that this contract should respect the ownership of.\n    function _transferOwnership(address newOwner, uint88 projectId) internal virtual {\n        // Can't set both a new owner and a new project ID.\n        if (projectId != 0 && newOwner != address(0)) {\n            revert INVALID_NEW_OWNER();\n        }\n        // Load the owner information from storage.\n        JBOwner memory ownerInfo = jbOwner;\n        // Get the address of the old owner.\n        address oldOwner = ownerInfo.projectId == 0 ? ownerInfo.owner : PROJECTS.ownerOf(ownerInfo.projectId);\n        // Update the stored owner information to the new owner and reset the `permissionId`.\n        // This is to prevent permissions clashes for the new user/owner.\n        jbOwner = JBOwner({owner: newOwner, projectId: projectId, permissionId: 0});\n        // Emit a transfer event with the new owner's address.\n        _emitTransferEvent(oldOwner, newOwner, projectId);\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Reverts if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        JBOwner memory ownerInfo = jbOwner;\n\n        _requirePermissionFrom({\n            account: ownerInfo.projectId == 0 ? ownerInfo.owner : PROJECTS.ownerOf(ownerInfo.projectId),\n            projectId: ownerInfo.projectId,\n            permissionId: ownerInfo.permissionId\n        });\n    }\n\n    /// @notice Either `newOwner` or `newProjectId` is non-zero or both are zero. But they can never both be non-zero.\n    /// @dev This function exists because some contracts will try to deploy contracts for a project before\n    function _emitTransferEvent(address previousOwner, address newOwner, uint88 newProjectId) internal virtual;\n}\n"
			},
			"node_modules/@bananapus/ownable/src/interfaces/IJBOwnable.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IJBOwnable {\n    event PermissionIdChanged(uint8 newIndex);\n\n    function jbOwner() external view returns (address owner, uint88 projectOwner, uint8 permissionId);\n\n    function transferOwnershipToProject(uint256 projectId) external;\n\n    function setPermissionId(uint8 permissionId) external;\n}\n"
			},
			"node_modules/@bananapus/ownable/src/struct/JBOwner.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/// @notice Owner information for a given instance of `JBOwnableOverrides`.\n/// @custom:member owner If `projectId` is 0 and this is set, this static address has owner access.\n/// @custom:member projectId Unless this is 0, this project's owner has owner access.\n/// @custom:member permissionId The ID of the permission required from the project's owner to have owner access. See\n/// `JBPermissions` in `juice-contracts-v4`.\nstruct JBOwner {\n    address owner;\n    uint88 projectId;\n    uint8 permissionId;\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.20;\n\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code repetition as possible, we write it in\n    // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\n    // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit in bytes32.\n\n    /**\n     * @dev Query for a nonexistent map key.\n     */\n    error EnumerableMapNonexistentKey(bytes32 key);\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 key => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        if (value == 0 && !contains(map, key)) {\n            revert EnumerableMapNonexistentKey(key);\n        }\n        return value;\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return map._keys.values();\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
			},
			"src/BPSuckerRegistry.sol": {
				"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.21;\n\nimport {JBOwnable, IJBProjects, IJBPermissions} from \"@bananapus/ownable/src/JBOwnable.sol\";\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {EnumerableMap} from \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport {IBPSucker} from \"./interfaces/IBPSucker.sol\";\nimport {IBPSuckerRegistry} from \"./interfaces/IBPSuckerRegistry.sol\";\nimport {BPSuckerDeployerConfig} from \"./structs/BPSuckerDeployerConfig.sol\";\nimport {BPSuckersPair} from \"./structs/BPSuckersPair.sol\";\n\ncontract BPSuckerRegistry is JBOwnable, IBPSuckerRegistry {\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n    error INVALID_DEPLOYER(address deployer);\n\n    /// @notice A constant indicating that this sucker exists and belongs to a specific project.\n    uint256 constant SUCKER_EXISTS = 1;\n\n    /// @notice Tracks the suckers for the specified project.\n    mapping(uint256 => EnumerableMap.AddressToUintMap) _suckersOf;\n\n    /// @notice Tracks whether the specified sucker deployer is approved by this registry.\n    mapping(address deployer => bool) public suckerDeployerIsAllowed;\n\n    constructor(IJBProjects projects, IJBPermissions permissions, address _initialOwner)\n        JBOwnable(projects, permissions, address(_initialOwner), 0)\n    {}\n\n    /// @notice Returns true if the specified sucker belongs to the specified project, and was deployed through this registry.\n    /// @param projectId The ID of the project to check for.\n    /// @param suckerAddress The address of the sucker to check.\n    function isSuckerOf(uint256 projectId, address suckerAddress) external view returns (bool) {\n        return _suckersOf[projectId].get(suckerAddress) == SUCKER_EXISTS;\n    }\n\n    /// @notice Gets all of the specified project's suckers which were deployed through this registry.\n    /// @param projectId The ID of the project to get the suckers of.\n    function suckersOf(uint256 projectId) external view returns (address[] memory) {\n        return _suckersOf[projectId].keys();\n    }\n\n    /// @notice Helper function for retrieving the projects suckers and their metadata.\n    /// @param projectId The ID of the project to get the suckers of.\n    function getSuckerPairs(uint256 projectId) external view returns (BPSuckersPair[] memory _pairs) {\n        address[] memory _suckers = _suckersOf[projectId].keys();\n        uint256 _n = _suckers.length;\n        _pairs = new BPSuckersPair[](_n);\n\n        for (uint256 _i = 0; _i < _n; _i++) {\n            IBPSucker _sucker = IBPSucker(_suckers[_i]);\n            _pairs[_i] =\n                BPSuckersPair({local: address(_sucker), remote: _sucker.PEER(), remoteChainId: _sucker.peerChainID()});\n        }\n    }\n\n    /// @notice Adds a suckers deployer to the allowlist.\n    /// @dev Can only be called by this contract's owner (initially project ID 1, or JuiceboxDAO).\n    /// @param deployer The address of the deployer to add.\n    function allowSuckerDeployer(address deployer) public override onlyOwner {\n        suckerDeployerIsAllowed[deployer] = true;\n        emit SuckerDeployerAllowed(deployer);\n    }\n\n    /// @notice Adds multiple suckers deployer to the allowlist.\n    /// @dev Can only be called by this contract's owner (initially project ID 1, or JuiceboxDAO).\n    /// @param deployers The address of the deployer to add.\n    function allowSuckerDeployers(address[] calldata deployers) public onlyOwner {\n        for (uint256 _i; _i < deployers.length; _i++) {\n            suckerDeployerIsAllowed[deployers[_i]] = true;\n            emit SuckerDeployerAllowed(deployers[_i]);\n        }\n    }\n\n    /// @notice Deploy one or more suckers for the specified project.\n    /// @dev The caller must be the project's owner or have `JBPermissionIds.DEPLOY_SUCKERS` from the project's owner.\n    /// @param projectId The ID of the project to deploy suckers for.\n    /// @param salt The salt used to deploy the contract. For the suckers to be peers, this must be the same value on each chain where suckers are deployed.\n    /// @param configurations The sucker deployer configs to use to deploy the suckers.\n    /// @return suckers The addresses of the deployed suckers.\n    function deploySuckersFor(uint256 projectId, bytes32 salt, BPSuckerDeployerConfig[] calldata configurations)\n        public\n        override\n        returns (address[] memory suckers)\n    {\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.DEPLOY_SUCKERS\n        });\n\n        // Create an array to store the suckers as they are deployed.\n        suckers = new address[](configurations.length);\n\n        // Calculate the salt using the sender's address and the provided `salt`.\n        // This means that for suckers to be peers, the sender has to be the same on each chain.\n        salt = keccak256(abi.encode(msg.sender, salt));\n\n        // Iterate through the configurations and deploy the suckers.\n        for (uint256 i; i < configurations.length; i++) {\n            // Make sure the deployer is allowed.\n            if (!suckerDeployerIsAllowed[address(configurations[i].deployer)]) {\n                revert INVALID_DEPLOYER(address(configurations[i].deployer));\n            }\n\n            // Create the sucker.\n            IBPSucker sucker = configurations[i].deployer.createForSender({localProjectId: projectId, salt: salt});\n            suckers[i] = address(sucker);\n\n            // Store the sucker as being deployed for this project.\n            _suckersOf[projectId].set(address(sucker), SUCKER_EXISTS);\n\n            // Map the tokens for the sucker.\n            sucker.mapTokens(configurations[i].mappings);\n        }\n\n        emit SuckersDeployedFor(projectId, suckers);\n    }\n\n    function _emitTransferEvent(address previousOwner, address newOwner, uint88 newProjectId)\n        internal\n        virtual\n        override\n    {\n        // Only emit after the initial transfer.\n        if (address(this).code.length != 0) {\n            emit OwnershipTransferred(previousOwner, newProjectId == 0 ? newOwner : PROJECTS.ownerOf(newProjectId));\n        }\n    }\n}\n"
			},
			"src/interfaces/IBPSuckerRegistry.sol": {
				"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.21;\n\nimport {BPSuckerDeployerConfig} from \"../structs/BPSuckerDeployerConfig.sol\";\n\ninterface IBPSuckerRegistry {\n    event SuckerDeployerAllowed(address deployer);\n    event SuckersDeployedFor(uint256 projectId, address[] suckers);\n\n    function isSuckerOf(uint256 projectId, address suckerAddress) external view returns (bool);\n    function suckersOf(uint256 projectId) external view returns (address[] memory);\n    function suckerDeployerIsAllowed(address deployer) external view returns (bool);\n\n    function allowSuckerDeployer(address deployer) external;\n    function deploySuckersFor(uint256 projectId, bytes32 salt, BPSuckerDeployerConfig[] memory configurations)\n        external\n        returns (address[] memory suckers);\n}\n"
			},
			"src/structs/BPSuckerDeployerConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBPSuckerDeployer} from \"../interfaces/IBPSuckerDeployer.sol\";\nimport {BPTokenMapping} from \"./BPTokenMapping.sol\";\n\nstruct BPSuckerDeployerConfig {\n    IBPSuckerDeployer deployer;\n    BPTokenMapping[] mappings;\n}\n"
			},
			"src/structs/BPSuckersPair.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nstruct BPSuckersPair {\n    address local;\n    address remote;\n    uint256 remoteChainId;\n}\n"
			}
		}
	}
}