{
	"solcVersion": "0.8.23",
	"solcLongVersion": "0.8.23",
	"id": "9b6dcb5b0ed176744688fe6ac33711bb",
	"input": {
		"language": "Solidity",
		"settings": {
			"viaIR": false,
			"optimizer": {
				"runs": 21000,
				"enabled": true
			},
			"metadata": {
				"useLiteralContent": false,
				"bytecodeHash": "ipfs",
				"appendCBOR": true
			},
			"outputSelection": {
				"lib/forge-std/lib/ds-test/src/test.sol": {
					"*": []
				},
				"lib/forge-std/src/Base.sol": {
					"*": []
				},
				"lib/forge-std/src/Script.sol": {
					"*": []
				},
				"lib/forge-std/src/StdAssertions.sol": {
					"*": []
				},
				"lib/forge-std/src/StdChains.sol": {
					"*": []
				},
				"lib/forge-std/src/StdCheats.sol": {
					"*": []
				},
				"lib/forge-std/src/StdError.sol": {
					"*": []
				},
				"lib/forge-std/src/StdInvariant.sol": {
					"*": []
				},
				"lib/forge-std/src/StdJson.sol": {
					"*": []
				},
				"lib/forge-std/src/StdMath.sol": {
					"*": []
				},
				"lib/forge-std/src/StdStorage.sol": {
					"*": []
				},
				"lib/forge-std/src/StdStyle.sol": {
					"*": []
				},
				"lib/forge-std/src/StdUtils.sol": {
					"*": []
				},
				"lib/forge-std/src/Test.sol": {
					"*": []
				},
				"lib/forge-std/src/Vm.sol": {
					"*": []
				},
				"lib/forge-std/src/console.sol": {
					"*": []
				},
				"lib/forge-std/src/console2.sol": {
					"*": []
				},
				"lib/forge-std/src/interfaces/IMulticall3.sol": {
					"*": []
				},
				"lib/forge-std/src/mocks/MockERC20.sol": {
					"*": []
				},
				"lib/forge-std/src/mocks/MockERC721.sol": {
					"*": []
				},
				"lib/forge-std/src/safeconsole.sol": {
					"*": []
				},
				"node_modules/@arbitrum/nitro-contracts/src/bridge/IBridge.sol": {
					"*": []
				},
				"node_modules/@arbitrum/nitro-contracts/src/bridge/IDelayedMessageProvider.sol": {
					"*": []
				},
				"node_modules/@arbitrum/nitro-contracts/src/bridge/IInbox.sol": {
					"*": []
				},
				"node_modules/@arbitrum/nitro-contracts/src/bridge/IInboxBase.sol": {
					"*": []
				},
				"node_modules/@arbitrum/nitro-contracts/src/bridge/IOutbox.sol": {
					"*": []
				},
				"node_modules/@arbitrum/nitro-contracts/src/bridge/IOwnable.sol": {
					"*": []
				},
				"node_modules/@arbitrum/nitro-contracts/src/bridge/ISequencerInbox.sol": {
					"*": []
				},
				"node_modules/@arbitrum/nitro-contracts/src/libraries/AddressAliasHelper.sol": {
					"*": []
				},
				"node_modules/@arbitrum/nitro-contracts/src/libraries/IGasRefunder.sol": {
					"*": []
				},
				"node_modules/@arbitrum/nitro-contracts/src/precompiles/ArbSys.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/script/helpers/CoreDeploymentLib.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBController.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBDirectory.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBFeelessAddresses.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBFundAccessLimits.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBMultiTerminal.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBPermissions.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBPrices.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBProjects.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBRulesets.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBSplits.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBTerminalStore.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBTokens.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/abstract/JBControlled.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/abstract/JBPermissioned.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/enums/JBApprovalStatus.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBControlled.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBController.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBDirectory.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBDirectoryAccessControl.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBFeeTerminal.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBFeelessAddresses.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBFundAccessLimits.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBMigratable.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBMultiTerminal.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPayHook.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPayoutTerminal.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPermissioned.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPermissions.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPermitTerminal.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPriceFeed.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPrices.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBProjectUriRegistry.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBProjects.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRedeemHook.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRedeemTerminal.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRulesetDataHook.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRulesets.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBSplitHook.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBSplits.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTerminal.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTerminalStore.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBToken.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTokenUriResolver.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTokens.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/libraries/JBConstants.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/libraries/JBFees.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/libraries/JBFixedPointNumber.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/libraries/JBMetadataResolver.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/libraries/JBRedemptions.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/libraries/JBRulesetMetadataResolver.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/libraries/JBSplitGroupIds.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/libraries/JBSurplus.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBAccountingContext.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBAfterPayRecordedContext.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBAfterRedeemRecordedContext.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBBeforePayRecordedContext.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBBeforeRedeemRecordedContext.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBCurrencyAmount.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBFee.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBFundAccessLimitGroup.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBPayHookSpecification.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBPermissionsData.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBRedeemHookSpecification.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBRuleset.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetConfig.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetMetadata.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetWeightCache.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetWithMetadata.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBSingleAllowance.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBSplit.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBSplitGroup.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBSplitHookContext.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBTerminalConfig.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBTokenAmount.sol": {
					"*": []
				},
				"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/access/Ownable.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/metatx/ERC2771Context.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/proxy/Clones.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/Address.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/Context.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/Strings.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/structs/BitMaps.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
					"*": []
				},
				"node_modules/@prb/math/src/Common.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/core/SphinxDataTypes.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/core/interfaces/ISphinxModule.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/core/interfaces/ISphinxModuleProxyFactory.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/StdUtils.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/Vm.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IERC165.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IERC20.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IERC721.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IMulticall3.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/mocks/MockERC20.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/mocks/MockERC721.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/Sphinx.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxConstants.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxForkCheck.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxPlugin.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxPluginTypes.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxUtils.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/ICreateCall.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IEnum.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IGnosisSafe.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IGnosisSafeProxy.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IGnosisSafeProxyFactory.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IMultiSend.sol": {
					"*": []
				},
				"node_modules/@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol": {
					"*": []
				},
				"node_modules/@uniswap/permit2/src/interfaces/IEIP712.sol": {
					"*": []
				},
				"node_modules/@uniswap/permit2/src/interfaces/IPermit2.sol": {
					"*": []
				},
				"node_modules/@uniswap/permit2/src/interfaces/ISignatureTransfer.sol": {
					"*": []
				},
				"script/Deploy.s.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/JBArbitrumSucker.sol": {
					"*": []
				},
				"src/JBBaseSucker.sol": {
					"*": []
				},
				"src/JBOptimismSucker.sol": {
					"*": []
				},
				"src/JBSucker.sol": {
					"*": []
				},
				"src/JBSuckerRegistry.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/deployers/JBArbitrumSuckerDeployer.sol": {
					"*": []
				},
				"src/deployers/JBBaseSuckerDeployer.sol": {
					"*": []
				},
				"src/deployers/JBOptimismSuckerDeployer.sol": {
					"*": []
				},
				"src/enums/JBAddToBalanceMode.sol": {
					"*": []
				},
				"src/enums/JBLayer.sol": {
					"*": []
				},
				"src/interfaces/IArbGatewayRouter.sol": {
					"*": []
				},
				"src/interfaces/IArbL1GatewayRouter.sol": {
					"*": []
				},
				"src/interfaces/IArbL2GatewayRouter.sol": {
					"*": []
				},
				"src/interfaces/IJBArbitrumSucker.sol": {
					"*": []
				},
				"src/interfaces/IJBArbitrumSuckerDeployer.sol": {
					"*": []
				},
				"src/interfaces/IJBOpSuckerDeployer.sol": {
					"*": []
				},
				"src/interfaces/IJBOptimismSucker.sol": {
					"*": []
				},
				"src/interfaces/IJBSucker.sol": {
					"*": []
				},
				"src/interfaces/IJBSuckerDeployer.sol": {
					"*": []
				},
				"src/interfaces/IJBSuckerRegistry.sol": {
					"*": []
				},
				"src/interfaces/IOPMessenger.sol": {
					"*": []
				},
				"src/interfaces/IOPStandardBridge.sol": {
					"*": []
				},
				"src/libraries/ARBAddresses.sol": {
					"*": []
				},
				"src/libraries/ARBChains.sol": {
					"*": []
				},
				"src/structs/JBClaim.sol": {
					"*": []
				},
				"src/structs/JBInboxTreeRoot.sol": {
					"*": []
				},
				"src/structs/JBLeaf.sol": {
					"*": []
				},
				"src/structs/JBMessageRoot.sol": {
					"*": []
				},
				"src/structs/JBOutboxTree.sol": {
					"*": []
				},
				"src/structs/JBRemoteToken.sol": {
					"*": []
				},
				"src/structs/JBSuckerDeployerConfig.sol": {
					"*": []
				},
				"src/structs/JBSuckersPair.sol": {
					"*": []
				},
				"src/structs/JBTokenMapping.sol": {
					"*": []
				},
				"src/utils/MerkleLib.sol": {
					"*": []
				},
				"test/unit/registry.t.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				}
			},
			"evmVersion": "paris",
			"libraries": {},
			"remappings": [
				"@sphinx-labs/contracts/=node_modules/@sphinx-labs/contracts/contracts/foundry/",
				"@arbitrum/=node_modules/@arbitrum/",
				"@bananapus/=node_modules/@bananapus/",
				"@chainlink/=node_modules/@chainlink/",
				"@eth-optimism/=node_modules/@eth-optimism/",
				"@offchainlabs/=node_modules/@offchainlabs/",
				"@openzeppelin/=node_modules/@openzeppelin/",
				"@prb/=node_modules/@prb/",
				"@scroll-tech/=node_modules/@scroll-tech/",
				"@uniswap/=node_modules/@uniswap/",
				"ds-test/=lib/forge-std/lib/ds-test/src/",
				"forge-std/=lib/forge-std/src/",
				"hardhat/=node_modules/hardhat/",
				"solmate/=node_modules/solmate/",
				"sphinx/=lib/sphinx/packages/contracts/contracts/forge-std/src/"
			]
		},
		"sources": {
			"node_modules/@bananapus/core/src/abstract/JBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {IJBPermissioned} from \"./../interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"./../interfaces/IJBPermissions.sol\";\n\n/// @notice Modifiers to allow access to transactions based on which permissions the message's sender has.\nabstract contract JBPermissioned is Context, IJBPermissioned {\n    //*********************************************************************//\n    // --------------------------- custom errors -------------------------- //\n    //*********************************************************************//\n\n    error JBPermissioned_Unauthorized(address account, address sender, uint256 projectId, uint256 permissionId);\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice A contract storing permissions.\n    IJBPermissions public immutable override PERMISSIONS;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    constructor(IJBPermissions permissions) {\n        PERMISSIONS = permissions;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Require the message sender to be the account or have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    function _requirePermissionFrom(address account, uint256 projectId, uint256 permissionId) internal view {\n        address sender = _msgSender();\n        if (\n            sender != account\n                && !PERMISSIONS.hasPermission({\n                    operator: sender,\n                    account: account,\n                    projectId: projectId,\n                    permissionId: permissionId,\n                    includeRoot: true,\n                    includeWildcardProjectId: true\n                })\n        ) revert JBPermissioned_Unauthorized(account, sender, projectId, permissionId);\n    }\n\n    /// @notice If the 'alsoGrantAccessIf' condition is truthy, proceed. Otherwise, require the message sender to be the\n    /// account or\n    /// have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    /// @param alsoGrantAccessIf An override condition which will allow access regardless of permissions.\n    function _requirePermissionAllowingOverrideFrom(\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool alsoGrantAccessIf\n    )\n        internal\n        view\n    {\n        if (alsoGrantAccessIf) return;\n        _requirePermissionFrom(account, projectId, permissionId);\n    }\n}\n"
			},
			"node_modules/@bananapus/core/src/enums/JBApprovalStatus.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A ruleset's approval status in a ruleset approval hook.\nenum JBApprovalStatus {\n    Empty,\n    Upcoming,\n    Active,\n    ApprovalExpected,\n    Approved,\n    Failed\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBController.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./IJBDirectoryAccessControl.sol\";\nimport {IJBFundAccessLimits} from \"./IJBFundAccessLimits.sol\";\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBPrices} from \"./IJBPrices.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBProjectUriRegistry} from \"./IJBProjectUriRegistry.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {IJBToken} from \"./IJBToken.sol\";\nimport {IJBTokens} from \"./IJBTokens.sol\";\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetConfig} from \"./../structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\nimport {JBRulesetWithMetadata} from \"./../structs/JBRulesetWithMetadata.sol\";\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {JBTerminalConfig} from \"./../structs/JBTerminalConfig.sol\";\n\ninterface IJBController is IERC165, IJBProjectUriRegistry, IJBDirectoryAccessControl {\n    event BurnTokens(\n        address indexed holder, uint256 indexed projectId, uint256 tokenCount, string memo, address caller\n    );\n    event LaunchProject(uint256 rulesetId, uint256 projectId, string projectUri, string memo, address caller);\n    event LaunchRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n    event MintTokens(\n        address indexed beneficiary,\n        uint256 indexed projectId,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        uint256 reservedPercent,\n        address caller\n    );\n    event PrepMigration(uint256 indexed projectId, address from, address caller);\n    event QueueRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n    event ReservedDistributionReverted(\n        uint256 indexed projectId, JBSplit split, uint256 tokenCount, bytes reason, address caller\n    );\n    event SendReservedTokensToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed groupId,\n        JBSplit split,\n        uint256 tokenCount,\n        address caller\n    );\n    event SendReservedTokensToSplits(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address owner,\n        uint256 tokenCount,\n        uint256 leftoverAmount,\n        address caller\n    );\n    event SetUri(uint256 indexed projectId, string uri, address caller);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n    function FUND_ACCESS_LIMITS() external view returns (IJBFundAccessLimits);\n    function PRICES() external view returns (IJBPrices);\n    function PROJECTS() external view returns (IJBProjects);\n    function RULESETS() external view returns (IJBRulesets);\n    function SPLITS() external view returns (IJBSplits);\n    function TOKENS() external view returns (IJBTokens);\n\n    function allRulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRulesetWithMetadata[] memory rulesets);\n    function currentRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory, JBRulesetMetadata memory metadata, JBApprovalStatus);\n    function pendingReservedTokenBalanceOf(uint256 projectId) external view returns (uint256);\n    function totalTokenSupplyWithReservedTokensOf(uint256 projectId) external view returns (uint256);\n    function upcomingRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function addPriceFeed(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n    function burnTokensOf(address holder, uint256 projectId, uint256 tokenCount, string calldata memo) external;\n    function claimTokensFor(address holder, uint256 projectId, uint256 tokenCount, address beneficiary) external;\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n    function launchProjectFor(\n        address owner,\n        string calldata projectUri,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 projectId);\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n    function mintTokensOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary,\n        string calldata memo,\n        bool useReservedPercent\n    )\n        external\n        returns (uint256 beneficiaryTokenCount);\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n    function sendReservedTokensToSplitsOf(uint256 projectId) external returns (uint256);\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] calldata splitGroups) external;\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 creditCount) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBDirectory.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\ninterface IJBDirectory {\n    event AddTerminal(uint256 indexed projectId, IJBTerminal indexed terminal, address caller);\n    event SetController(uint256 indexed projectId, IERC165 indexed controller, address caller);\n    event SetIsAllowedToSetFirstController(address indexed addr, bool indexed isAllowed, address caller);\n    event SetPrimaryTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed terminal, address caller\n    );\n    event SetTerminals(uint256 indexed projectId, IJBTerminal[] terminals, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function controllerOf(uint256 projectId) external view returns (IERC165);\n    function isAllowedToSetFirstController(address account) external view returns (bool);\n    function isTerminalOf(uint256 projectId, IJBTerminal terminal) external view returns (bool);\n    function primaryTerminalOf(uint256 projectId, address token) external view returns (IJBTerminal);\n    function terminalsOf(uint256 projectId) external view returns (IJBTerminal[] memory);\n\n    function setControllerOf(uint256 projectId, IERC165 controller) external;\n    function setIsAllowedToSetFirstController(address account, bool flag) external;\n    function setPrimaryTerminalOf(uint256 projectId, address token, IJBTerminal terminal) external;\n    function setTerminalsOf(uint256 projectId, IJBTerminal[] calldata terminals) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBDirectoryAccessControl.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBDirectoryAccessControl {\n    function setControllerAllowed(uint256 projectId) external view returns (bool);\n    function setTerminalsAllowed(uint256 projectId) external view returns (bool);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBFundAccessLimits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./../structs/JBCurrencyAmount.sol\";\nimport {JBFundAccessLimitGroup} from \"./../structs/JBFundAccessLimitGroup.sol\";\n\ninterface IJBFundAccessLimits {\n    event SetFundAccessLimits(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        JBFundAccessLimitGroup fundAccessLimitGroup,\n        address caller\n    );\n\n    function payoutLimitOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 payoutLimit);\n    function payoutLimitsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory payoutLimits);\n    function surplusAllowanceOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 surplusAllowance);\n    function surplusAllowancesOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory surplusAllowances);\n\n    function setFundAccessLimitsFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBFundAccessLimitGroup[] memory fundAccessLimitGroups\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPayHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterPayRecordedContext} from \"./../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `pay(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBPayHook is IERC165 {\n    /// @notice This function is called by the terminal's `pay(...)` function after the payment has been recorded in the\n    /// terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterPayRecordedContext` struct.\n    function afterPayRecordedWith(JBAfterPayRecordedContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPermissions} from \"./IJBPermissions.sol\";\n\ninterface IJBPermissioned {\n    function PERMISSIONS() external view returns (IJBPermissions);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPermissions.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBPermissionsData} from \"./../structs/JBPermissionsData.sol\";\n\ninterface IJBPermissions {\n    event OperatorPermissionsSet(\n        address indexed operator,\n        address indexed account,\n        uint256 indexed projectId,\n        uint8[] permissionIds,\n        uint256 packed,\n        address caller\n    );\n\n    function WILDCARD_PROJECT_ID() external view returns (uint256);\n\n    function permissionsOf(address operator, address account, uint256 projectId) external view returns (uint256);\n\n    function hasPermission(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function hasPermissions(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256[] calldata permissionIds,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function setPermissionsFor(address account, JBPermissionsData calldata permissionsData) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPriceFeed.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBPriceFeed {\n    function currentUnitPrice(uint256 targetDecimals) external view returns (uint256);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPrices.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBPrices {\n    event AddPriceFeed(\n        uint256 indexed projectId,\n        uint256 indexed pricingCurrency,\n        uint256 indexed unitCurrency,\n        IJBPriceFeed feed,\n        address caller\n    );\n\n    function DEFAULT_PROJECT_ID() external view returns (uint256);\n    function PROJECTS() external view returns (IJBProjects);\n\n    function priceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency\n    )\n        external\n        view\n        returns (IJBPriceFeed);\n    function pricePerUnitOf(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        uint256 decimals\n    )\n        external\n        view\n        returns (uint256);\n\n    function addPriceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBProjectUriRegistry.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBProjectUriRegistry {\n    function uriOf(uint256 projectId) external view returns (string memory);\n    function setUriOf(uint256 projectId, string calldata uri) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBProjects.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {IJBTokenUriResolver} from \"./IJBTokenUriResolver.sol\";\n\ninterface IJBProjects is IERC721 {\n    event Create(uint256 indexed projectId, address indexed owner, address caller);\n    event SetTokenUriResolver(IJBTokenUriResolver indexed resolver, address caller);\n\n    function count() external view returns (uint256);\n    function tokenUriResolver() external view returns (IJBTokenUriResolver);\n\n    function createFor(address owner) external returns (uint256 projectId);\n    function setTokenUriResolver(IJBTokenUriResolver resolver) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\n\n/// @notice `IJBRulesetApprovalHook`s are used to determine whether the next ruleset in the ruleset queue is approved or\n/// rejected.\n/// @dev Project rulesets are stored in a queue. Rulesets take effect after the previous ruleset in the queue ends, and\n/// only if they are approved by the previous ruleset's approval hook.\ninterface IJBRulesetApprovalHook is IERC165 {\n    function DURATION() external view returns (uint256);\n\n    function approvalStatusOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 start\n    )\n        external\n        view\n        returns (JBApprovalStatus);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesets.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {IJBRulesetApprovalHook} from \"./IJBRulesetApprovalHook.sol\";\n\ninterface IJBRulesets {\n    event RulesetInitialized(\n        uint256 indexed rulesetId, uint256 indexed projectId, uint256 indexed basedOnId, address caller\n    );\n    event RulesetQueued(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 decayPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter,\n        address caller\n    );\n\n    function latestRulesetIdOf(uint256 projectId) external view returns (uint256);\n\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId) external view returns (JBApprovalStatus);\n    function currentOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n    function getRulesetOf(uint256 projectId, uint256 rulesetId) external view returns (JBRuleset memory);\n    function latestQueuedOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus);\n    function allOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRuleset[] memory rulesets);\n    function upcomingOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 decayPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        returns (JBRuleset memory ruleset);\n    function updateRulesetWeightCache(uint256 projectId) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBSplitHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBSplitHookContext} from \"../structs/JBSplitHookContext.sol\";\n\n/// @title Split hook\n/// @notice Allows processing a single split with custom logic.\n/// @dev The split hook's address should be set as the `hook` in the relevant split.\ninterface IJBSplitHook is IERC165 {\n    /// @notice If a split has a split hook, payment terminals and controllers call this function while processing the\n    /// split.\n    /// @dev Critical business logic should be protected by appropriate access control. The tokens and/or native tokens\n    /// are optimistically transferred to the split hook when this function is called.\n    /// @param context The context passed by the terminal/controller to the split hook as a `JBSplitHookContext` struct:\n    function processSplitWith(JBSplitHookContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBSplits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\n\ninterface IJBSplits {\n    event SetSplit(\n        uint256 indexed projectId, uint256 indexed rulesetId, uint256 indexed groupId, JBSplit split, address caller\n    );\n\n    function FALLBACK_RULESET_ID() external view returns (uint256);\n\n    function splitsOf(uint256 projectId, uint256 rulesetId, uint256 groupId) external view returns (JBSplit[] memory);\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] memory splitGroups) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBPayHook} from \"./IJBPayHook.sol\";\nimport {JBAccountingContext} from \"../structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice A terminal that accepts payments and can be migrated.\ninterface IJBTerminal is IERC165 {\n    event AddToBalance(\n        uint256 indexed projectId, uint256 amount, uint256 returnedFees, string memo, bytes metadata, address caller\n    );\n    event HookAfterRecordPay(\n        IJBPayHook indexed hook, JBAfterPayRecordedContext context, uint256 specificationAmount, address caller\n    );\n\n    event MigrateTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed to, uint256 amount, address caller\n    );\n    event Pay(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address payer,\n        address beneficiary,\n        uint256 amount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        bytes metadata,\n        address caller\n    );\n    event SetAccountingContext(uint256 indexed projectId, JBAccountingContext context, address caller);\n\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        returns (JBAccountingContext memory);\n    function accountingContextsOf(uint256 projectId) external view returns (JBAccountingContext[] memory);\n    function currentSurplusOf(uint256 projectId, uint256 decimals, uint256 currency) external view returns (uint256);\n\n    function addAccountingContextsFor(uint256 projectId, JBAccountingContext[] calldata accountingContexts) external;\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable;\n    function migrateBalanceOf(uint256 projectId, address token, IJBTerminal to) external returns (uint256 balance);\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        returns (uint256 beneficiaryTokenCount);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBToken.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBToken {\n    function balanceOf(address account) external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n\n    function initialize(string memory name, string memory symbol, address owner) external;\n    function burn(address account, uint256 amount) external;\n    function mint(address account, uint256 amount) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTokenUriResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBTokenUriResolver {\n    function getUri(uint256 projectId) external view returns (string memory tokenUri);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTokens.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBToken} from \"./IJBToken.sol\";\n\ninterface IJBTokens {\n    event DeployERC20(\n        uint256 indexed projectId, IJBToken indexed token, string name, string symbol, bytes32 salt, address caller\n    );\n    event Burn(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 count,\n        uint256 creditBalance,\n        uint256 tokenBalance,\n        address caller\n    );\n    event ClaimTokens(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 creditBalance,\n        uint256 count,\n        address beneficiary,\n        address caller\n    );\n    event Mint(\n        address indexed holder, uint256 indexed projectId, uint256 count, bool shouldClaimTokens, address caller\n    );\n    event SetToken(uint256 indexed projectId, IJBToken indexed token, address caller);\n    event TransferCredits(\n        address indexed holder, uint256 indexed projectId, address indexed recipient, uint256 count, address caller\n    );\n\n    function creditBalanceOf(address holder, uint256 projectId) external view returns (uint256);\n    function projectIdOf(IJBToken token) external view returns (uint256);\n    function tokenOf(uint256 projectId) external view returns (IJBToken);\n    function totalCreditSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalBalanceOf(address holder, uint256 projectId) external view returns (uint256 result);\n    function totalSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function burnFrom(address holder, uint256 projectId, uint256 count) external;\n    function claimTokensFor(address holder, uint256 projectId, uint256 count, address beneficiary) external;\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n    function mintFor(address holder, uint256 projectId, uint256 count) external;\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 count) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAccountingContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The address of the token that accounting is being done with.\n/// @custom:member decimals The number of decimals expected in that token's fixed point accounting.\n/// @custom:member currency The currency that the token is priced in terms of. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBAccountingContext {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAfterPayRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member payer The address the payment originated from.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member amount The payment's token amount. Includes the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the pay hook. Includes the token\n/// being paid, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member weight The current ruleset's weight (used to determine how many tokens should be minted).\n/// @custom:member projectTokenCount The number of project tokens minted for the beneficiary.\n/// @custom:member beneficiary The address which receives any tokens this payment yields.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the pay hook.\n/// @custom:member payerMetadata Extra data specified by the payer, which is sent to the pay hook.\nstruct JBAfterPayRecordedContext {\n    address payer;\n    uint256 projectId;\n    uint256 rulesetId;\n    JBTokenAmount amount;\n    JBTokenAmount forwardedAmount;\n    uint256 weight;\n    uint256 projectTokenCount;\n    address beneficiary;\n    bytes hookMetadata;\n    bytes payerMetadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBCurrencyAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member amount The amount of the currency.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBCurrencyAmount {\n    uint224 amount;\n    uint32 currency;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBFundAccessLimitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./JBCurrencyAmount.sol\";\n\n/// @dev Payout limit example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH, then\n/// the project can pay out 5 USD worth of ETH during a ruleset.\n/// @dev Surplus allowance example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH,\n/// then the project can pay out 5 USD worth of ETH from its surplus during a ruleset. A project's surplus is its\n/// balance minus its current combined payout limit.\n/// @dev If a project has multiple payout limits or surplus allowances, they are all available. They can all be used\n/// during a single ruleset.\n/// @dev The payout limits' and surplus allowances' fixed point amounts have the same number of decimals as the\n/// terminal.\n/// @custom:member terminal The terminal that the payout limits and surplus allowances apply to.\n/// @custom:member token The token that the payout limits and surplus allowances apply to within the `terminal`.\n/// @custom:member payoutLimits An array of payout limits. The payout limits cumulatively dictate the maximum value of\n/// `token`s a project can pay out from its balance in a terminal during a ruleset. Each payout limit can have a unique\n/// currency and amount.\n/// @custom:member surplusAllowances An array of surplus allowances. The surplus allowances cumulatively dictates the\n/// maximum value of `token`s a project can pay out from its surplus (balance less payouts) in a terminal during a\n/// ruleset. Each surplus allowance can have a unique currency and amount.\nstruct JBFundAccessLimitGroup {\n    address terminal;\n    address token;\n    JBCurrencyAmount[] payoutLimits;\n    JBCurrencyAmount[] surplusAllowances;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBPermissionsData.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member operator The address that permissions are being given to.\n/// @custom:member projectId The ID of the project the operator is being given permissions for. Operators only have\n/// permissions under this project's scope. An ID of 0 is a wildcard, which gives an operator permissions across all\n/// projects.\n/// @custom:member permissionIds The IDs of the permissions being given. See the `JBPermissionIds` library.\nstruct JBPermissionsData {\n    address operator;\n    uint56 projectId;\n    uint8[] permissionIds;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRuleset.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"./../interfaces/IJBRulesetApprovalHook.sol\";\n\n/// @dev `JBRuleset` timestamps are unix timestamps (seconds since 00:00 January 1st, 1970 UTC).\n/// @custom:member cycleNumber The ruleset's cycle number. Each ruleset's `cycleNumber` is the previous ruleset's\n/// `cycleNumber` plus one. Each project's first ruleset has a `cycleNumber` of 1.\n/// @custom:member id The ruleset's ID, which is a timestamp of when this ruleset's rules were initialized. The\n/// `rulesetId` stays the same for rulesets that automatically cycle over from a manually queued ruleset.\n/// @custom:member basedOnId The `rulesetId` of the ruleset which was active when this ruleset was created.\n/// @custom:member start The timestamp from which this ruleset is considered active.\n/// @custom:member duration The number of seconds the ruleset lasts for. After this duration, a new ruleset will start.\n/// The project owner can queue new rulesets at any time, which will take effect once the current ruleset's duration is\n/// over. If the `duration` is 0, newly queued rulesets will take effect immediately. If a ruleset ends and there are no\n/// new rulesets queued, the current ruleset cycles over to another one with the same properties but a new `start`\n/// timestamp and a `weight` reduced by the ruleset's `decayPercent`.\n/// @custom:member weight A fixed point number with 18 decimals which is typically used by payment terminals to\n/// determine how many tokens should be minted when a payment is received. This can be used by other contracts for\n/// arbitrary calculations.\n/// @custom:member decayPercent The percentage by which to reduce the `weight` each time a new ruleset starts. `weight`\n/// is\n/// a percentage out of `JBConstants.MAX_DECAY_PERCENT`. If it's 0, the next ruleset will have the same `weight` by\n/// default. If it's 90%, the next ruleset's `weight` will be 10% smaller. If a ruleset explicitly sets a new `weight`,\n/// the `decayPercent` doesn't apply.\n/// @custom:member approvalHook An address of a contract that says whether a queued ruleset should be approved or\n/// rejected. If a\n/// ruleset is rejected, it won't go into effect. An approval hook can be used to create rules which dictate how a\n/// project owner can change their ruleset over time.\n/// @custom:member metadata Extra data associated with a ruleset which can be used by other contracts.\nstruct JBRuleset {\n    uint48 cycleNumber;\n    uint48 id;\n    uint48 basedOnId;\n    uint48 start;\n    uint32 duration;\n    uint112 weight;\n    uint32 decayPercent;\n    IJBRulesetApprovalHook approvalHook;\n    uint256 metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"../interfaces/IJBRulesetApprovalHook.sol\";\nimport {JBFundAccessLimitGroup} from \"./JBFundAccessLimitGroup.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\nimport {JBSplitGroup} from \"./JBSplitGroup.sol\";\n\n/// @custom:member mustStartAtOrAfter The earliest time the ruleset can start.\n/// @custom:member duration The number of seconds the ruleset lasts for, after which a new ruleset will start. A\n/// duration of 0 means that the ruleset will stay active until the project owner explicitly issues a reconfiguration,\n/// at which point a new ruleset will immediately start with the updated properties. If the duration is greater than 0,\n/// a project owner cannot make changes to a ruleset's parameters while it is active – any proposed changes will apply\n/// to the subsequent ruleset. If no changes are proposed, a ruleset rolls over to another one with the same properties\n/// but new `start` timestamp and a decayed `weight`.\n/// @custom:member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations\n/// on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is\n/// received.\n/// @custom:member decayPercent A percent by how much the `weight` of the subsequent ruleset should be reduced, if the\n/// project owner hasn't queued the subsequent ruleset with an explicit `weight`. If it's 0, each ruleset will have\n/// equal weight. If the number is 90%, the next ruleset will have a 10% smaller weight. This weight is out of\n/// `JBConstants.MAX_DECAY_PERCENT`.\n/// @custom:member approvalHook An address of a contract that says whether a proposed ruleset should be accepted or\n/// rejected. It\n/// can be used to create rules around how a project owner can change ruleset parameters over time.\n/// @custom:member metadata Metadata specifying the controller-specific parameters that a ruleset can have. These\n/// properties cannot change until the next ruleset starts.\n/// @custom:member splitGroups An array of splits to use for any number of groups while the ruleset is active.\n/// @custom:member fundAccessLimitGroups An array of structs which dictate the amount of funds a project can access from\n/// its balance in each payment terminal while the ruleset is active. Amounts are fixed point numbers using the same\n/// number of decimals as the corresponding terminal. The `_payoutLimit` and `_surplusAllowance` parameters must fit in\n/// a `uint232`.\nstruct JBRulesetConfig {\n    uint48 mustStartAtOrAfter;\n    uint32 duration;\n    uint112 weight;\n    uint32 decayPercent;\n    IJBRulesetApprovalHook approvalHook;\n    JBRulesetMetadata metadata;\n    JBSplitGroup[] splitGroups;\n    JBFundAccessLimitGroup[] fundAccessLimitGroups;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member reservedPercent The reserved percent of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_RESERVED_PERCENT`.\n/// @custom:member redemptionRate The redemption rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_REDEMPTION_RATE`.\n/// @custom:member baseCurrency The currency on which to base the ruleset's weight. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member pausePay A flag indicating if the pay functionality should be paused during the ruleset.\n/// @custom:member pauseCreditTransfers A flag indicating if the project token transfer functionality should be paused\n/// during the funding cycle.\n/// @custom:member allowOwnerMinting A flag indicating if the project owner or an operator with the `MINT_TOKENS`\n/// permission from the owner should be allowed to mint project tokens on demand during this ruleset.\n/// @custom:member allowTerminalMigration A flag indicating if migrating terminals should be allowed during this\n/// ruleset.\n/// @custom:member allowSetTerminals A flag indicating if a project's terminals can be added or removed.\n/// @custom:member allowSetController A flag indicating if a project's controller can be changed.\n/// @custom:member allowAddAccountingContext A flag indicating if a project can add new accounting contexts for its\n/// terminals to use.\n/// @custom:member allowAddPriceFeed A flag indicating if a project can add new price feeds to calculate exchange rates\n/// between its tokens.\n/// @custom:member allowCrosschainSuckerExtension A flag indicating if the crosschain sucker extension should be\n/// allowed during this ruleset.\n/// @custom:member ownerMustSendPayouts A flag indicating if privileged payout distribution should be\n/// enforced, otherwise payouts can be distributed by anyone.\n/// @custom:member holdFees A flag indicating if fees should be held during this ruleset.\n/// @custom:member useTotalSurplusForRedemptions A flag indicating if redemptions should use the project's balance held\n/// in all terminals instead of the project's local terminal balance from which the redemption is being fulfilled.\n/// @custom:member useDataHookForPay A flag indicating if the data hook should be used for pay transactions during this\n/// ruleset.\n/// @custom:member useDataHookForRedeem A flag indicating if the data hook should be used for redeem transactions during\n/// this ruleset.\n/// @custom:member dataHook The data hook to use during this ruleset.\n/// @custom:member metadata Metadata of the metadata, up to uint16 in size though only the first 14 bits can be used.\nstruct JBRulesetMetadata {\n    uint16 reservedPercent;\n    uint16 redemptionRate;\n    uint32 baseCurrency;\n    bool pausePay;\n    bool pauseCreditTransfers;\n    bool allowOwnerMinting;\n    bool allowSetCustomToken;\n    bool allowTerminalMigration;\n    bool allowSetTerminals;\n    bool allowSetController;\n    bool allowAddAccountingContext;\n    bool allowAddPriceFeed;\n    bool allowCrosschainSuckerExtension;\n    bool ownerMustSendPayouts;\n    bool holdFees;\n    bool useTotalSurplusForRedemptions;\n    bool useDataHookForPay;\n    bool useDataHookForRedeem;\n    address dataHook;\n    uint16 metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetWithMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBRuleset} from \"./JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\n\n/// @custom:member ruleset The ruleset.\n/// @custom:member metadata The ruleset's metadata.\nstruct JBRulesetWithMetadata {\n    JBRuleset ruleset;\n    JBRulesetMetadata metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplit.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSplitHook} from \"./../interfaces/IJBSplitHook.sol\";\n\n/// @notice Splits are used to send a percentage of a total token amount to a specific contract, project, or address.\n/// Splits are used to send payouts and reserved tokens.\n/// @dev 1. If a non-zero split hook contract is specified, this split's tokens are sent there along with this split's\n/// properties.\n/// @dev 2. Otherwise, if a non-zero project ID is specified, this split's tokens are used to `pay` it through its\n/// terminal if possible, or sent to the project's owner if not. If this payment yields tokens, those go to the split's\n/// `beneficiary`.\n/// @dev 3. Otherwise, this split's tokens are sent directly to the `beneficiary`.\n/// @dev To summarize, this split's tokens are sent according to the following priority: `split hook` > `projectId` >\n/// `beneficiary`.\n/// @custom:member preferAddToBalance If this split were to `pay` a project through its terminal, this flag indicates\n/// whether it should prefer using the terminal's `addToBalance` function instead.\n/// @custom:member percent The percent of the total token amount that this split sends. This number is out of\n/// `JBConstants.SPLITS_TOTAL_PERCENT`.\n/// @custom:member projectId The ID of a project to `pay`, if applicable. Resulting tokens will be routed to the\n/// `beneficiary`.\n/// @custom:member beneficiary Receives this split's tokens if the `hook` and `projectId` are zero. If the `projectId`\n/// is specified, the `beneficiary` receives any project tokens minted by this split.\n/// @custom:member lockedUntil The split cannot be changed until this timestamp. The `lockedUntil` timestamp can be\n/// increased while a split is locked. If `lockedUntil` is zero, this split can be changed at any time.\n/// @custom:member hook A contract which will receive this split's tokens and properties, and can define custom\n/// behavior.\nstruct JBSplit {\n    bool preferAddToBalance;\n    uint32 percent;\n    uint56 projectId;\n    address payable beneficiary;\n    uint48 lockedUntil;\n    IJBSplitHook hook;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member groupId An identifier for the group. By convention, this ID is `uint256(uint160(tokenAddress))` for\n/// payouts and `1` for reserved tokens.\n/// @custom:member splits The splits in the group.\nstruct JBSplitGroup {\n    uint256 groupId;\n    JBSplit[] splits;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplitHookContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member token The token being sent to the split hook.\n/// @custom:member amount The amount being sent to the split hook, as a fixed point number.\n/// @custom:member decimals The number of decimals in the amount.\n/// @custom:member projectId The project the split belongs to.\n/// @custom:member groupId The group the split belongs to. By convention, this ID is `uint256(uint160(tokenAddress))`\n/// for payouts and `1` for reserved tokens.\n/// @custom:member split The split which specified the hook.\nstruct JBSplitHookContext {\n    address token;\n    uint256 amount;\n    uint256 decimals;\n    uint256 projectId;\n    uint256 groupId;\n    JBSplit split;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBTerminalConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBAccountingContext} from \"./JBAccountingContext.sol\";\nimport {IJBTerminal} from \"./../interfaces/IJBTerminal.sol\";\n\n/// @custom:member terminal The terminal to configure.\n/// @custom:member accountingContextsToAccept The accounting contexts to accept from the terminal.\nstruct JBTerminalConfig {\n    IJBTerminal terminal;\n    JBAccountingContext[] accountingContextsToAccept;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBTokenAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The token the payment was made in.\n/// @custom:member decimals The number of decimals included in the value fixed point number.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member value The amount of tokens that was paid, as a fixed point number.\nstruct JBTokenAmount {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n    uint256 value;\n}\n"
			},
			"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Permission IDs for `JBPermissions`, used throughout the Bananapus ecosystem. See\n/// [`JBPermissions`](https://github.com/Bananapus/nana-core/blob/main/src/JBPermissions.sol)\n/// @dev `JBPermissions` allows one address to grant another address permission to call functions in Juicebox contracts\n/// on their behalf. Each ID in `JBPermissionIds` grants access to a specific set of these functions.\nlibrary JBPermissionIds {\n    uint8 internal constant ROOT = 1; // All permissions across every contract. Very dangerous. BE CAREFUL!\n\n    /* Used by `nana-core`: https://github.com/Bananapus/nana-core */\n    uint8 internal constant QUEUE_RULESETS = 2; // Permission to call `JBController.queueRulesetsOf` and\n        // `JBController.launchRulesetsFor`.\n    uint8 internal constant REDEEM_TOKENS = 3; // Permission to call `JBMultiTerminal.redeemTokensOf`.\n    uint8 internal constant SEND_PAYOUTS = 4; // Permission to call `JBMultiTerminal.sendPayoutsOf`.\n    uint8 internal constant MIGRATE_TERMINAL = 5; // Permission to call `JBMultiTerminal.migrateBalanceOf`.\n    uint8 internal constant SET_PROJECT_URI = 6; // Permission to call `JBController.setUriOf`.\n    uint8 internal constant DEPLOY_ERC20 = 7; // Permission to call `JBController.deployERC20For`.\n    uint8 internal constant SET_TOKEN = 8; // Permission to call `JBController.setTokenFor`.\n    uint8 internal constant MINT_TOKENS = 9; // Permission to call `JBController.mintTokensOf`.\n    uint8 internal constant BURN_TOKENS = 10; // Permission to call `JBController.burnTokensOf`.\n    uint8 internal constant CLAIM_TOKENS = 11; // Permission to call `JBController.claimTokensFor`.\n    uint8 internal constant TRANSFER_CREDITS = 12; // Permission to call `JBController.transferCreditsFrom`.\n    uint8 internal constant SET_CONTROLLER = 13; // Permission to call `JBDirectory.setControllerOf`.\n    uint8 internal constant SET_TERMINALS = 14; // Permission to call `JBDirectory.setTerminalsOf`.\n    // Be careful - `SET_TERMINALS` can be used to remove the primary terminal.\n    uint8 internal constant SET_PRIMARY_TERMINAL = 15; // Permission to call `JBDirectory.setPrimaryTerminalOf`.\n    uint8 internal constant USE_ALLOWANCE = 16; // Permission to call `JBMultiTerminal.useAllowanceOf`.\n    uint8 internal constant SET_SPLIT_GROUPS = 17; // Permission to call `JBController.setSplitGroupsOf`.\n    uint8 internal constant ADD_PRICE_FEED = 18; // Permission to call `JBPrices.addPriceFeedFor`.\n    uint8 internal constant ADD_ACCOUNTING_CONTEXTS = 19; // Permission to call\n        // `JBMultiTerminal.addAccountingContextsFor`.\n\n    /* Used by `nana-721-hook`: https://github.com/Bananapus/nana-721-hook */\n    uint8 internal constant ADJUST_721_TIERS = 20; // Permission to call `JB721TiersHook.adjustTiers`.\n    uint8 internal constant SET_721_METADATA = 21; // Permission to call `JB721TiersHook.setMetadata`.\n    uint8 internal constant MINT_721 = 22; // Permission to call `JB721TiersHook.mintFor`.\n    uint8 internal constant SET_721_DISCOUNT_PERCENT = 23; // Permission to call `JB721TiersHook.setDiscountPercentOf`.\n\n    /* Used by `nana-buyback-hook`: https://github.com/Bananapus/nana-buyback-hook */\n    uint8 internal constant SET_BUYBACK_TWAP = 24; // Permission to call `JBBuybackHook.setTwapWindowOf` and\n        // `JBBuybackHook.setTwapSlippageToleranceOf`.\n    uint8 internal constant SET_BUYBACK_POOL = 25; // Permission to call `JBBuybackHook.setPoolFor`.\n\n    /* Used by `nana-swap-terminal`: https://github.com/Bananapus/nana-swap-terminal */\n    uint8 internal constant ADD_SWAP_TERMINAL_POOL = 26; // Permission to call `JBSwapTerminal.addDefaultPool`.\n    uint8 internal constant ADD_SWAP_TERMINAL_TWAP_PARAMS = 27; // Permission to call\n        // `JBSwapTerminal.addTwapParamsFor`.\n\n    /* Used by `nana-suckers`: https://github.com/Bananapus/nana-suckers */\n    uint8 internal constant MAP_SUCKER_TOKEN = 28; // Permission to call `BPSucker.mapToken`.\n    uint8 internal constant DEPLOY_SUCKERS = 29; // Permission to call `BPSuckerRegistry.deploySuckersFor`.\n}\n"
			},
			"node_modules/@openzeppelin/contracts/access/Ownable.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.20;\n\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code repetition as possible, we write it in\n    // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\n    // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit in bytes32.\n\n    /**\n     * @dev Query for a nonexistent map key.\n     */\n    error EnumerableMapNonexistentKey(bytes32 key);\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 key => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        if (value == 0 && !contains(map, key)) {\n            revert EnumerableMapNonexistentKey(key);\n        }\n        return value;\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return map._keys.values();\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
			},
			"src/JBSuckerRegistry.sol": {
				"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {JBPermissioned} from \"@bananapus/core/src/abstract/JBPermissioned.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {JBRuleset} from \"@bananapus/core/src/structs/JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"@bananapus/core/src/structs/JBRulesetMetadata.sol\";\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {EnumerableMap} from \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\n\nimport {IJBSucker} from \"./interfaces/IJBSucker.sol\";\nimport {IJBSuckerDeployer} from \"./interfaces/IJBSuckerDeployer.sol\";\nimport {IJBSuckerRegistry} from \"./interfaces/IJBSuckerRegistry.sol\";\nimport {JBSuckerDeployerConfig} from \"./structs/JBSuckerDeployerConfig.sol\";\nimport {JBSuckersPair} from \"./structs/JBSuckersPair.sol\";\n\ncontract JBSuckerRegistry is Ownable, JBPermissioned, IJBSuckerRegistry {\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error JBSuckerRegistry_InvalidDeployer(IJBSuckerDeployer deployer);\n    error JBSuckerRegistry_RulesetDoesNotAllowAddingSucker();\n\n    //*********************************************************************//\n    // ------------------------- internal constants ----------------------- //\n    //*********************************************************************//\n\n    /// @notice A constant indicating that this sucker exists and belongs to a specific project.\n    uint256 internal constant _SUCKER_EXISTS = 1;\n\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    /// @notice The juicebox directory.\n    IJBDirectory public immutable override DIRECTORY;\n\n    /// @notice A contract which mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable override PROJECTS;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice Tracks whether the specified sucker deployer is approved by this registry.\n    /// @custom:member deployer The address of the deployer to check.\n    mapping(address deployer => bool) public override suckerDeployerIsAllowed;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------- //\n    //*********************************************************************//\n\n    /// @notice Tracks the suckers for the specified project.\n    mapping(uint256 => EnumerableMap.AddressToUintMap) internal _suckersOf;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory The juicebox directory.\n    /// @param permissions A contract storing permissions.\n    /// @param initialOwner The initial owner of this contract.\n    constructor(\n        IJBDirectory directory,\n        IJBPermissions permissions,\n        address initialOwner\n    )\n        JBPermissioned(permissions)\n        Ownable(initialOwner)\n    {\n        DIRECTORY = directory;\n        PROJECTS = directory.PROJECTS();\n    }\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Returns true if the specified sucker belongs to the specified project, and was deployed through this\n    /// registry.\n    /// @param projectId The ID of the project to check for.\n    /// @param addr The address of the sucker to check.\n    /// @return flag A flag indicating if the sucker belongs to the project, and was deployed through this registry.\n    function isSuckerOf(uint256 projectId, address addr) external view override returns (bool) {\n        return _suckersOf[projectId].get(addr) == _SUCKER_EXISTS;\n    }\n\n    /// @notice Helper function for retrieving the projects suckers and their metadata.\n    /// @param projectId The ID of the project to get the suckers of.\n    /// @return pairs The pairs of suckers and their metadata.\n    function getSuckerPairs(uint256 projectId) external view returns (JBSuckersPair[] memory pairs) {\n        // Get the suckers of the project.\n        address[] memory suckers = _suckersOf[projectId].keys();\n\n        // Keep a reference to the number of suckers.\n        uint256 numberOfSuckers = suckers.length;\n\n        // Initialize the array of pairs.\n        pairs = new JBSuckersPair[](numberOfSuckers);\n\n        // Populate the array of pairs.\n        for (uint256 i; i < numberOfSuckers; i++) {\n            // Get the sucker being iterated over.\n            IJBSucker sucker = IJBSucker(suckers[i]);\n\n            // slither-disable-next-line calls-loop\n            pairs[i] =\n                JBSuckersPair({local: address(sucker), remote: sucker.PEER(), remoteChainId: sucker.peerChainId()});\n        }\n    }\n\n    /// @notice Gets all of the specified project's suckers which were deployed through this registry.\n    /// @param projectId The ID of the project to get the suckers of.\n    /// @return suckers The addresses of the suckers.\n    function suckersOf(uint256 projectId) external view override returns (address[] memory) {\n        return _suckersOf[projectId].keys();\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Adds a suckers deployer to the allowlist.\n    /// @dev Can only be called by this contract's owner (initially project ID 1, or JuiceboxDAO).\n    /// @param deployer The address of the deployer to add.\n    function allowSuckerDeployer(address deployer) public override onlyOwner {\n        suckerDeployerIsAllowed[deployer] = true;\n        emit SuckerDeployerAllowed({deployer: deployer, caller: msg.sender});\n    }\n\n    /// @notice Adds multiple suckers deployer to the allowlist.\n    /// @dev Can only be called by this contract's owner (initially project ID 1, or JuiceboxDAO).\n    /// @param deployers The address of the deployer to add.\n    function allowSuckerDeployers(address[] calldata deployers) public onlyOwner {\n        // Keep a reference to the number of deployers.\n        uint256 numberOfDeployers = deployers.length;\n\n        // Iterate through the deployers and allow them.\n        for (uint256 i; i < numberOfDeployers; i++) {\n            // Get the deployer being iterated over.\n            address deployer = deployers[i];\n\n            // Allow the deployer.\n            suckerDeployerIsAllowed[deployer] = true;\n            emit SuckerDeployerAllowed({deployer: deployer, caller: msg.sender});\n        }\n    }\n\n    /// @notice Deploy one or more suckers for the specified project.\n    /// @dev The caller must be the project's owner or have `JBPermissionIds.DEPLOY_SUCKERS` from the project's owner.\n    /// @param projectId The ID of the project to deploy suckers for.\n    /// @param salt The salt used to deploy the contract. For the suckers to be peers, this must be the same value on\n    /// each chain where suckers are deployed.\n    /// @param configurations The sucker deployer configs to use to deploy the suckers.\n    /// @return suckers The addresses of the deployed suckers.\n    function deploySuckersFor(\n        uint256 projectId,\n        bytes32 salt,\n        JBSuckerDeployerConfig[] calldata configurations\n    )\n        public\n        override\n        returns (address[] memory suckers)\n    {\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.DEPLOY_SUCKERS\n        });\n\n        // Check if the ruleset allows adding a sucker.\n        _requireRulesetAllowsAddingSucker({projectId: projectId});\n\n        // Create an array to store the suckers as they are deployed.\n        suckers = new address[](configurations.length);\n\n        // Calculate the salt using the sender's address and the provided `salt`.\n        // This means that for suckers to be peers, the sender has to be the same on each chain.\n        salt = keccak256(abi.encode(msg.sender, salt));\n\n        // Keep a reference to the number of configurations.\n        uint256 numberOfConfigurations = configurations.length;\n\n        // Iterate through the configurations and deploy the suckers.\n        for (uint256 i; i < numberOfConfigurations; i++) {\n            // Get the configuration being iterated over.\n            JBSuckerDeployerConfig memory configuration = configurations[i];\n\n            // Make sure the deployer is allowed.\n            if (!suckerDeployerIsAllowed[address(configuration.deployer)]) {\n                revert JBSuckerRegistry_InvalidDeployer(configuration.deployer);\n            }\n\n            // Create the sucker.\n            // slither-disable-next-line reentrancy-event,calls-loop\n            IJBSucker sucker = configuration.deployer.createForSender({localProjectId: projectId, salt: salt});\n            suckers[i] = address(sucker);\n\n            // Store the sucker as being deployed for this project.\n            // slither-disable-next-line unused-return\n            _suckersOf[projectId].set({key: address(sucker), value: _SUCKER_EXISTS});\n\n            // Map the tokens for the sucker.\n            // slither-disable-next-line reentrancy-events,calls-loop\n            sucker.mapTokens(configuration.mappings);\n            emit SuckerDeployedFor({\n                projectId: projectId,\n                sucker: address(sucker),\n                configuration: configuration,\n                caller: msg.sender\n            });\n        }\n    }\n\n    //*********************************************************************//\n    // --------------------- internal transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Checks if the current ruleset allows adding a sucker.\n    /// @dev Reverts if the ruleset does not allow adding a sucker.\n    /// @param projectId The ID of the project to check.\n    function _requireRulesetAllowsAddingSucker(uint256 projectId) internal view {\n        // Get the controller of the project.\n        IJBController controller = IJBController(address(DIRECTORY.controllerOf(projectId)));\n\n        // Get the ruleset metadata of the project.\n        // slither-disable-next-line unused-return\n        (JBRuleset memory ruleset, JBRulesetMetadata memory metadata) = controller.currentRulesetOf(projectId);\n\n        // Check if this transaction is a deployment.\n        // TODO: Reconsider if we should handle it this way before the first ruleset.j\n        bool isDeployment = false;\n        if (ruleset.id == 0) {\n            (ruleset,) = controller.upcomingRulesetOf(projectId);\n\n            if (ruleset.id == block.timestamp) {\n                isDeployment = true;\n            }\n        }\n\n        // Check if the ruleset allows adding a sucker and that this is *not* the deployment transaction.\n        if (!isDeployment && !metadata.allowCrosschainSuckerExtension) {\n            revert JBSuckerRegistry_RulesetDoesNotAllowAddingSucker();\n        }\n    }\n}\n"
			},
			"src/enums/JBAddToBalanceMode.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Options for how a `JBSucker`'s `amountToAddToBalance` gets added to its project's balance.\n/// @custom:element MANUAL The amount gets added to the project's balance manually by calling\n/// `addOutstandingAmountToBalance`.\n/// @custom:element ON_CLAIM The amount gets added to the project's balance automatically when `claim` is called.\nenum JBAddToBalanceMode {\n    MANUAL,\n    ON_CLAIM\n}\n"
			},
			"src/interfaces/IJBSucker.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBTokens} from \"@bananapus/core/src/interfaces/IJBTokens.sol\";\n\nimport {JBAddToBalanceMode} from \"../enums/JBAddToBalanceMode.sol\";\nimport {JBInboxTreeRoot} from \"../structs/JBInboxTreeRoot.sol\";\nimport {JBOutboxTree} from \"../structs/JBOutboxTree.sol\";\nimport {JBRemoteToken} from \"../structs/JBRemoteToken.sol\";\nimport {JBTokenMapping} from \"../structs/JBTokenMapping.sol\";\n\ninterface IJBSucker {\n    event Claimed(\n        address beneficiary,\n        address token,\n        uint256 projectTokenCount,\n        uint256 terminalTokenAmount,\n        uint256 index,\n        bool autoAddedToBalance,\n        address caller\n    );\n    event InsertToOutboxTree(\n        address indexed beneficiary,\n        address indexed token,\n        bytes32 hashed,\n        uint256 index,\n        bytes32 root,\n        uint256 projectTokenCount,\n        uint256 terminalTokenAmount,\n        address caller\n    );\n    event NewInboxTreeRoot(address indexed token, uint64 nonce, bytes32 root, address caller);\n    event RootToRemote(bytes32 indexed root, address indexed token, uint256 index, uint64 nonce, address caller);\n\n    function MESSENGER_BASE_GAS_LIMIT() external view returns (uint32);\n    function MESSENGER_ERC20_MIN_GAS_LIMIT() external view returns (uint32);\n\n    function ADD_TO_BALANCE_MODE() external view returns (JBAddToBalanceMode);\n    function DEPLOYER() external view returns (address);\n    function DIRECTORY() external view returns (IJBDirectory);\n    function PEER() external view returns (address);\n    function PROJECT_ID() external view returns (uint256);\n    function TOKENS() external view returns (IJBTokens);\n\n    function amountToAddToBalanceOf(address token) external view returns (uint256 amount);\n    function inboxOf(address token) external view returns (JBInboxTreeRoot memory);\n    function outboxOf(address token) external view returns (JBOutboxTree memory);\n    function remoteTokenFor(address token) external view returns (JBRemoteToken memory);\n\n    function peerChainId() external view returns (uint256 chainId);\n    function isMapped(address token) external view returns (bool);\n\n    function prepare(\n        uint256 projectTokenAmount,\n        address beneficiary,\n        uint256 minTokensReclaimed,\n        address token\n    )\n        external;\n    function mapToken(JBTokenMapping calldata map) external;\n    function mapTokens(JBTokenMapping[] calldata maps) external;\n}\n"
			},
			"src/interfaces/IJBSuckerDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBTokens} from \"@bananapus/core/src/interfaces/IJBTokens.sol\";\n\nimport {IJBSucker} from \"./IJBSucker.sol\";\n\ninterface IJBSuckerDeployer {\n    function DIRECTORY() external view returns (IJBDirectory);\n    function TOKENS() external view returns (IJBTokens);\n    function LAYER_SPECIFIC_CONFIGURATOR() external view returns (address);\n\n    function isSucker(address sucker) external view returns (bool);\n    function tempStoreId() external view returns (uint256);\n\n    function createForSender(uint256 localProjectId, bytes32 salt) external returns (IJBSucker sucker);\n}\n"
			},
			"src/interfaces/IJBSuckerRegistry.sol": {
				"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.21;\n\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\n\nimport {JBSuckerDeployerConfig} from \"../structs/JBSuckerDeployerConfig.sol\";\n\ninterface IJBSuckerRegistry {\n    event SuckerDeployedFor(uint256 projectId, address sucker, JBSuckerDeployerConfig configuration, address caller);\n    event SuckerDeployerAllowed(address deployer, address caller);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n    function PROJECTS() external view returns (IJBProjects);\n\n    function isSuckerOf(uint256 projectId, address addr) external view returns (bool);\n    function suckersOf(uint256 projectId) external view returns (address[] memory);\n    function suckerDeployerIsAllowed(address deployer) external view returns (bool);\n\n    function allowSuckerDeployer(address deployer) external;\n    function deploySuckersFor(\n        uint256 projectId,\n        bytes32 salt,\n        JBSuckerDeployerConfig[] memory configurations\n    )\n        external\n        returns (address[] memory suckers);\n}\n"
			},
			"src/structs/JBInboxTreeRoot.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice The root of an inbox tree for a given token in a `JBSucker`.\n/// @dev Inbox trees are used to receive from the remote chain to the local chain. Tokens can be `claim`ed from the\n/// inbox tree.\n/// @custom:member nonce Tracks the nonce of the tree. The nonce cannot decrease.\n/// @custom:member root The root of the tree.\nstruct JBInboxTreeRoot {\n    uint64 nonce;\n    bytes32 root;\n}\n"
			},
			"src/structs/JBOutboxTree.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {MerkleLib} from \"../utils/MerkleLib.sol\";\n\n/// @notice A merkle tree used to track the outbox for a given token in a `JBSucker`.\n/// @dev The outbox is used to send from the local chain to the remote chain.\n/// @custom:member nonce The nonce of the outbox.\n/// @custom:member balance The balance of the outbox.\n/// @custom:member tree The merkle tree.\nstruct JBOutboxTree {\n    uint64 nonce;\n    uint256 balance;\n    MerkleLib.Tree tree;\n}\n"
			},
			"src/structs/JBRemoteToken.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A struct that represents a token on the remote chain.\n/// @custom:member minGas The minimum gas to use when bridging.\n/// @custom:member addr The address of the token on the remote chain.\n/// @custom:member minBridgeAmount The minimum amount to bridge.\nstruct JBRemoteToken {\n    uint32 minGas;\n    address addr;\n    uint256 minBridgeAmount;\n}\n"
			},
			"src/structs/JBSuckerDeployerConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSuckerDeployer} from \"../interfaces/IJBSuckerDeployer.sol\";\nimport {JBTokenMapping} from \"./JBTokenMapping.sol\";\n\n/// @custom:member deployer The deployer to use.\n/// @custom:member mappings The token mappings to use.\nstruct JBSuckerDeployerConfig {\n    IJBSuckerDeployer deployer;\n    JBTokenMapping[] mappings;\n}\n"
			},
			"src/structs/JBSuckersPair.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/// @custom:member local The local address.\n/// @custom:member remote The remote address.\n/// @custom:member remoteChainId The chain ID of the remote address.\nstruct JBSuckersPair {\n    address local;\n    address remote;\n    uint256 remoteChainId;\n}\n"
			},
			"src/structs/JBTokenMapping.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member localToken The local token address.\n/// @custom:member minGas The minimum gas amount to bridge.\n/// @custom:member remoteToken The remote token address.\n/// @custom:member minBridgeAmount The minimum bridge amount.\nstruct JBTokenMapping {\n    address localToken;\n    uint32 minGas;\n    address remoteToken;\n    uint256 minBridgeAmount;\n}\n"
			},
			"src/utils/MerkleLib.sol": {
				"content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.23;\n\n/**\n * @title MerkleLib\n * @author Illusory Systems Inc.\n * @notice An incremental merkle tree modeled on the eth2 deposit contract.\n *\n */\nlibrary MerkleLib {\n    // ========== Custom Errors ===========\n\n    error MerkleLib__insert_treeIsFull();\n\n    // ============ Constants =============\n\n    uint256 internal constant TREE_DEPTH = 32;\n    uint256 internal constant MAX_LEAVES = 2 ** TREE_DEPTH - 1;\n\n    /**\n     * @dev Z_i represent the hash values at different heights for a binary tree with leaf values equal to `0`.\n     * (e.g. Z_1 is the keccak256 hash of (0x0, 0x0), Z_2 is the keccak256 hash of (Z_1, Z_1), etc...)\n     * Z_0 is the bottom of the 33-layer tree, Z_32 is the top (i.e. root).\n     * Used to shortcut calculation in root calculation methods below.\n     */\n    bytes32 internal constant Z_0 = hex\"0000000000000000000000000000000000000000000000000000000000000000\";\n    bytes32 internal constant Z_1 = hex\"ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5\";\n    bytes32 internal constant Z_2 = hex\"b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30\";\n    bytes32 internal constant Z_3 = hex\"21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85\";\n    bytes32 internal constant Z_4 = hex\"e58769b32a1beaf1ea27375a44095a0d1fb664ce2dd358e7fcbfb78c26a19344\";\n    bytes32 internal constant Z_5 = hex\"0eb01ebfc9ed27500cd4dfc979272d1f0913cc9f66540d7e8005811109e1cf2d\";\n    bytes32 internal constant Z_6 = hex\"887c22bd8750d34016ac3c66b5ff102dacdd73f6b014e710b51e8022af9a1968\";\n    bytes32 internal constant Z_7 = hex\"ffd70157e48063fc33c97a050f7f640233bf646cc98d9524c6b92bcf3ab56f83\";\n    bytes32 internal constant Z_8 = hex\"9867cc5f7f196b93bae1e27e6320742445d290f2263827498b54fec539f756af\";\n    bytes32 internal constant Z_9 = hex\"cefad4e508c098b9a7e1d8feb19955fb02ba9675585078710969d3440f5054e0\";\n    bytes32 internal constant Z_10 = hex\"f9dc3e7fe016e050eff260334f18a5d4fe391d82092319f5964f2e2eb7c1c3a5\";\n    bytes32 internal constant Z_11 = hex\"f8b13a49e282f609c317a833fb8d976d11517c571d1221a265d25af778ecf892\";\n    bytes32 internal constant Z_12 = hex\"3490c6ceeb450aecdc82e28293031d10c7d73bf85e57bf041a97360aa2c5d99c\";\n    bytes32 internal constant Z_13 = hex\"c1df82d9c4b87413eae2ef048f94b4d3554cea73d92b0f7af96e0271c691e2bb\";\n    bytes32 internal constant Z_14 = hex\"5c67add7c6caf302256adedf7ab114da0acfe870d449a3a489f781d659e8becc\";\n    bytes32 internal constant Z_15 = hex\"da7bce9f4e8618b6bd2f4132ce798cdc7a60e7e1460a7299e3c6342a579626d2\";\n    bytes32 internal constant Z_16 = hex\"2733e50f526ec2fa19a22b31e8ed50f23cd1fdf94c9154ed3a7609a2f1ff981f\";\n    bytes32 internal constant Z_17 = hex\"e1d3b5c807b281e4683cc6d6315cf95b9ade8641defcb32372f1c126e398ef7a\";\n    bytes32 internal constant Z_18 = hex\"5a2dce0a8a7f68bb74560f8f71837c2c2ebbcbf7fffb42ae1896f13f7c7479a0\";\n    bytes32 internal constant Z_19 = hex\"b46a28b6f55540f89444f63de0378e3d121be09e06cc9ded1c20e65876d36aa0\";\n    bytes32 internal constant Z_20 = hex\"c65e9645644786b620e2dd2ad648ddfcbf4a7e5b1a3a4ecfe7f64667a3f0b7e2\";\n    bytes32 internal constant Z_21 = hex\"f4418588ed35a2458cffeb39b93d26f18d2ab13bdce6aee58e7b99359ec2dfd9\";\n    bytes32 internal constant Z_22 = hex\"5a9c16dc00d6ef18b7933a6f8dc65ccb55667138776f7dea101070dc8796e377\";\n    bytes32 internal constant Z_23 = hex\"4df84f40ae0c8229d0d6069e5c8f39a7c299677a09d367fc7b05e3bc380ee652\";\n    bytes32 internal constant Z_24 = hex\"cdc72595f74c7b1043d0e1ffbab734648c838dfb0527d971b602bc216c9619ef\";\n    bytes32 internal constant Z_25 = hex\"0abf5ac974a1ed57f4050aa510dd9c74f508277b39d7973bb2dfccc5eeb0618d\";\n    bytes32 internal constant Z_26 = hex\"b8cd74046ff337f0a7bf2c8e03e10f642c1886798d71806ab1e888d9e5ee87d0\";\n    bytes32 internal constant Z_27 = hex\"838c5655cb21c6cb83313b5a631175dff4963772cce9108188b34ac87c81c41e\";\n    bytes32 internal constant Z_28 = hex\"662ee4dd2dd7b2bc707961b1e646c4047669dcb6584f0d8d770daf5d7e7deb2e\";\n    bytes32 internal constant Z_29 = hex\"388ab20e2573d171a88108e79d820e98f26c0b84aa8b2f4aa4968dbb818ea322\";\n    bytes32 internal constant Z_30 = hex\"93237c50ba75ee485f4c22adf2f741400bdf8d6a9cc7df7ecae576221665d735\";\n    bytes32 internal constant Z_31 = hex\"8448818bb4ae4562849e949e17ac16e0be16688e156b5cf15e098c627c0056a9\";\n    bytes32 internal constant Z_32 = hex\"27ae5ba08d7291c96c8cbddcc148bf48a6d68c7974b94356f53754ef6171d757\";\n\n    // ============= Structs ==============\n\n    /**\n     * @notice Struct representing incremental merkle tree. Contains current\n     * branch and the number of inserted leaves in the tree.\n     *\n     */\n    struct Tree {\n        bytes32[TREE_DEPTH] branch;\n        uint256 count;\n    }\n\n    // ========= Write Methods =========\n\n    /**\n     * @notice Inserts a given node (leaf) into merkle tree. Operates on an in-memory tree and\n     * returns an updated version of that tree.\n     * @dev Reverts if the tree is already full.\n     * @param node Element to insert into tree.\n     * @return Tree Updated tree.\n     *\n     */\n    function insert(Tree memory tree, bytes32 node) internal pure returns (Tree memory) {\n        // Update tree.count to increase the current count by 1 since we'll be including a new node.\n        uint256 size = ++tree.count;\n        if (size > MAX_LEAVES) revert MerkleLib__insert_treeIsFull();\n\n        // Loop starting at 0, ending when we've finished inserting the node (i.e. hashing it) into\n        // the active branch. Each loop we cut size in half, hashing the inserted node up the active\n        // branch along the way.\n        for (uint256 i; i < TREE_DEPTH;) {\n            // Check if the current size is odd; if so, we set this index in the branch to be the node.\n            if ((size & 1) == 1) {\n                // If i > 0, then this node will be a hash of the original node with every layer up\n                // until layer `i`.\n                tree.branch[i] = node;\n                return tree;\n            }\n            // If the size is not yet odd, we hash the current index in the tree branch with the node.\n            node = keccak256(abi.encodePacked(tree.branch[i], node));\n            size >>= 1; // Cut size in half (statement equivalent to: `size /= 2`).\n\n            unchecked {\n                ++i;\n            }\n        }\n        // As the loop should always end prematurely with the `return` statement, this code should\n        // be unreachable. We revert here just to be safe.\n        revert MerkleLib__insert_treeIsFull();\n    }\n\n    // ========= Read Methods =========\n\n    /**\n     * @notice Calculates and returns tree's current root.\n     * @return _current bytes32 root.\n     *\n     */\n    function root(Tree storage tree) internal view returns (bytes32 _current) {\n        uint256 _index = tree.count;\n\n        if (_index == 0) {\n            return Z_32;\n        }\n\n        uint256 i;\n        assembly {\n            let TREE_SLOT := tree.slot\n\n            for {} true {} {\n                for {} true {} {\n                    if and(_index, 1) {\n                        mstore(0, sload(TREE_SLOT))\n                        mstore(0x20, Z_0)\n                        _current := keccak256(0, 0x40)\n                        break\n                    }\n\n                    if and(_index, shl(1, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 1)))\n                        mstore(0x20, Z_1)\n                        _current := keccak256(0, 0x40)\n                        i := 1\n                        break\n                    }\n\n                    if and(_index, shl(2, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 2)))\n                        mstore(0x20, Z_2)\n                        _current := keccak256(0, 0x40)\n                        i := 2\n                        break\n                    }\n\n                    if and(_index, shl(3, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 3)))\n                        mstore(0x20, Z_3)\n                        _current := keccak256(0, 0x40)\n                        i := 3\n                        break\n                    }\n\n                    if and(_index, shl(4, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 4)))\n                        mstore(0x20, Z_4)\n                        _current := keccak256(0, 0x40)\n                        i := 4\n                        break\n                    }\n\n                    if and(_index, shl(5, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 5)))\n                        mstore(0x20, Z_5)\n                        _current := keccak256(0, 0x40)\n                        i := 5\n                        break\n                    }\n\n                    if and(_index, shl(6, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 6)))\n                        mstore(0x20, Z_6)\n                        _current := keccak256(0, 0x40)\n                        i := 6\n                        break\n                    }\n\n                    if and(_index, shl(7, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 7)))\n                        mstore(0x20, Z_7)\n                        _current := keccak256(0, 0x40)\n                        i := 7\n                        break\n                    }\n\n                    if and(_index, shl(8, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 8)))\n                        mstore(0x20, Z_8)\n                        _current := keccak256(0, 0x40)\n                        i := 8\n                        break\n                    }\n\n                    if and(_index, shl(9, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 9)))\n                        mstore(0x20, Z_9)\n                        _current := keccak256(0, 0x40)\n                        i := 9\n                        break\n                    }\n\n                    if and(_index, shl(10, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 10)))\n                        mstore(0x20, Z_10)\n                        _current := keccak256(0, 0x40)\n                        i := 10\n                        break\n                    }\n\n                    if and(_index, shl(11, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 11)))\n                        mstore(0x20, Z_11)\n                        _current := keccak256(0, 0x40)\n                        i := 11\n                        break\n                    }\n\n                    if and(_index, shl(12, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 12)))\n                        mstore(0x20, Z_12)\n                        _current := keccak256(0, 0x40)\n                        i := 12\n                        break\n                    }\n\n                    if and(_index, shl(13, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 13)))\n                        mstore(0x20, Z_13)\n                        _current := keccak256(0, 0x40)\n                        i := 13\n                        break\n                    }\n\n                    if and(_index, shl(14, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 14)))\n                        mstore(0x20, Z_14)\n                        _current := keccak256(0, 0x40)\n                        i := 14\n                        break\n                    }\n\n                    if and(_index, shl(15, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 15)))\n                        mstore(0x20, Z_15)\n                        _current := keccak256(0, 0x40)\n                        i := 15\n                        break\n                    }\n\n                    if and(_index, shl(16, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 16)))\n                        mstore(0x20, Z_16)\n                        _current := keccak256(0, 0x40)\n                        i := 16\n                        break\n                    }\n\n                    if and(_index, shl(17, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 17)))\n                        mstore(0x20, Z_17)\n                        _current := keccak256(0, 0x40)\n                        i := 17\n                        break\n                    }\n\n                    if and(_index, shl(18, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 18)))\n                        mstore(0x20, Z_18)\n                        _current := keccak256(0, 0x40)\n                        i := 18\n                        break\n                    }\n\n                    if and(_index, shl(19, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 19)))\n                        mstore(0x20, Z_19)\n                        _current := keccak256(0, 0x40)\n                        i := 19\n                        break\n                    }\n\n                    if and(_index, shl(20, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 20)))\n                        mstore(0x20, Z_20)\n                        _current := keccak256(0, 0x40)\n                        i := 20\n                        break\n                    }\n\n                    if and(_index, shl(21, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 21)))\n                        mstore(0x20, Z_21)\n                        _current := keccak256(0, 0x40)\n                        i := 21\n                        break\n                    }\n\n                    if and(_index, shl(22, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 22)))\n                        mstore(0x20, Z_22)\n                        _current := keccak256(0, 0x40)\n                        i := 22\n                        break\n                    }\n\n                    if and(_index, shl(23, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 23)))\n                        mstore(0x20, Z_23)\n                        _current := keccak256(0, 0x40)\n                        i := 23\n                        break\n                    }\n\n                    if and(_index, shl(24, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 24)))\n                        mstore(0x20, Z_24)\n                        _current := keccak256(0, 0x40)\n                        i := 24\n                        break\n                    }\n\n                    if and(_index, shl(25, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 25)))\n                        mstore(0x20, Z_25)\n                        _current := keccak256(0, 0x40)\n                        i := 25\n                        break\n                    }\n\n                    if and(_index, shl(26, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 26)))\n                        mstore(0x20, Z_26)\n                        _current := keccak256(0, 0x40)\n                        i := 26\n                        break\n                    }\n\n                    if and(_index, shl(27, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 27)))\n                        mstore(0x20, Z_27)\n                        _current := keccak256(0, 0x40)\n                        i := 27\n                        break\n                    }\n\n                    if and(_index, shl(28, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 28)))\n                        mstore(0x20, Z_28)\n                        _current := keccak256(0, 0x40)\n                        i := 28\n                        break\n                    }\n\n                    if and(_index, shl(29, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 29)))\n                        mstore(0x20, Z_29)\n                        _current := keccak256(0, 0x40)\n                        i := 29\n                        break\n                    }\n\n                    if and(_index, shl(30, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 30)))\n                        mstore(0x20, Z_30)\n                        _current := keccak256(0, 0x40)\n                        i := 30\n                        break\n                    }\n\n                    if and(_index, shl(31, 1)) {\n                        mstore(0, sload(add(TREE_SLOT, 31)))\n                        mstore(0x20, Z_31)\n                        _current := keccak256(0, 0x40)\n                        // slither-disable-next-line write-after-write\n                        i := 31\n                        break\n                    }\n\n                    // slither-disable-next-line write-after-write\n                    _current := Z_32\n                    i := 32\n                    break\n                }\n\n                if gt(i, 30) { break }\n\n                {\n                    if lt(i, 1) {\n                        switch and(_index, shl(1, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_1)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 1)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 2) {\n                        switch and(_index, shl(2, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_2)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 2)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 3) {\n                        switch and(_index, shl(3, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_3)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 3)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 4) {\n                        switch and(_index, shl(4, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_4)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 4)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 5) {\n                        switch and(_index, shl(5, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_5)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 5)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 6) {\n                        switch and(_index, shl(6, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_6)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 6)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 7) {\n                        switch and(_index, shl(7, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_7)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 7)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 8) {\n                        switch and(_index, shl(8, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_8)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 8)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 9) {\n                        switch and(_index, shl(9, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_9)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 9)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 10) {\n                        switch and(_index, shl(10, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_10)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 10)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 11) {\n                        switch and(_index, shl(11, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_11)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 11)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 12) {\n                        switch and(_index, shl(12, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_12)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 12)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 13) {\n                        switch and(_index, shl(13, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_13)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 13)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 14) {\n                        switch and(_index, shl(14, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_14)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 14)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 15) {\n                        switch and(_index, shl(15, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_15)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 15)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 16) {\n                        switch and(_index, shl(16, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_16)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 16)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 17) {\n                        switch and(_index, shl(17, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_17)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 17)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 18) {\n                        switch and(_index, shl(18, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_18)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 18)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 19) {\n                        switch and(_index, shl(19, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_19)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 19)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 20) {\n                        switch and(_index, shl(20, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_20)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 20)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 21) {\n                        switch and(_index, shl(21, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_21)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 21)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 22) {\n                        switch and(_index, shl(22, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_22)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 22)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 23) {\n                        switch and(_index, shl(23, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_23)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 23)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 24) {\n                        switch and(_index, shl(24, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_24)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 24)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 25) {\n                        switch and(_index, shl(25, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_25)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 25)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 26) {\n                        switch and(_index, shl(26, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_26)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 26)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 27) {\n                        switch and(_index, shl(27, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_27)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 27)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 28) {\n                        switch and(_index, shl(28, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_28)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 28)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 29) {\n                        switch and(_index, shl(29, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_29)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 29)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 30) {\n                        switch and(_index, shl(30, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_30)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 30)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n\n                    if lt(i, 31) {\n                        switch and(_index, shl(31, 1))\n                        case 0 {\n                            mstore(0, _current)\n                            mstore(0x20, Z_31)\n                        }\n                        default {\n                            mstore(0, sload(add(TREE_SLOT, 31)))\n                            mstore(0x20, _current)\n                        }\n\n                        _current := keccak256(0, 0x40)\n                    }\n                }\n\n                break\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates and returns the merkle root for the given leaf `_item`,\n     * a merkle branch, and the index of `_item` in the tree.\n     * @param _item Merkle leaf\n     * @param _branch Merkle proof\n     * @param _index Index of `_item` in tree\n     * @return _current Calculated merkle root\n     *\n     */\n    function branchRoot(\n        bytes32 _item,\n        bytes32[TREE_DEPTH] memory _branch,\n        uint256 _index\n    )\n        internal\n        pure\n        returns (bytes32 _current)\n    {\n        assembly {\n            _current := _item\n            let BRANCH_DATA_OFFSET := _branch\n            let f\n\n            f := shl(5, and(_index, 1))\n            mstore(f, _current)\n            mstore(sub(0x20, f), mload(BRANCH_DATA_OFFSET))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(1, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 1))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(2, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 2))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(3, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 3))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(4, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 4))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(5, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 5))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(6, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 6))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(7, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 7))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(8, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 8))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(9, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 9))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(10, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 10))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(11, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 11))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(12, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 12))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(13, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 13))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(14, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 14))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(15, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 15))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(16, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 16))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(17, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 17))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(18, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 18))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(19, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 19))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(20, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 20))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(21, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 21))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(22, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 22))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(23, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 23))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(24, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 24))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(25, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 25))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(26, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 26))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(27, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 27))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(28, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 28))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(29, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 29))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(30, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 30))))\n            _current := keccak256(0, 0x40)\n\n            f := shl(5, iszero(and(_index, shl(31, 1))))\n            mstore(sub(0x20, f), _current)\n            mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 31))))\n            _current := keccak256(0, 0x40)\n        }\n    }\n}\n"
			}
		}
	}
}